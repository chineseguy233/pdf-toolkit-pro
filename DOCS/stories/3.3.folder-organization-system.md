# Story 3.3: 文件夹组织系统

## Status
Draft

## Story
**As a** 用户,
**I want** 系统能够根据PDF内容自动建议文件夹结构并整理文件,
**so that** 我能够建立有序的文档管理体系

## Acceptance Criteria
1. 基于文档类型和内容自动建议文件夹结构
2. 支持多级文件夹层次结构（最多3级）
3. 提供预定义的组织模板（按类型、日期、项目等）
4. 支持拖拽方式移动文件到建议文件夹
5. 实现批量文件整理功能
6. 文件夹建议准确率达到75%以上

## Tasks / Subtasks
- [ ] 实现文件夹结构分析 (AC: 1, 6)
  - [ ] 基于文档分类生成文件夹建议
  - [ ] 分析现有文件夹结构模式
  - [ ] 实现智能文件夹命名
  - [ ] 优化文件夹层次深度控制
- [ ] 开发多级层次管理 (AC: 2)
  - [ ] 实现3级文件夹深度限制
  - [ ] 创建层次结构验证机制
  - [ ] 优化文件夹嵌套逻辑
  - [ ] 添加层次结构可视化
- [ ] 创建组织模板系统 (AC: 3)
  - [ ] 设计预定义组织模板
  - [ ] 实现模板应用和自定义
  - [ ] 添加模板保存和分享功能
  - [ ] 创建模板效果预览
- [ ] 实现拖拽整理功能 (AC: 4)
  - [ ] 开发文件拖拽交互
  - [ ] 实现文件夹拖拽接收
  - [ ] 添加拖拽视觉反馈
  - [ ] 处理拖拽冲突和验证
- [ ] 开发批量整理功能 (AC: 5)
  - [ ] 实现多文件选择和批量移动
  - [ ] 添加整理进度显示
  - [ ] 创建整理结果报告
  - [ ] 实现批量操作撤销

## Dev Notes

### 文件夹组织架构
```typescript
interface FolderStructure {
  id: string;
  name: string;
  path: string;
  level: number;
  parent?: string;
  children: FolderStructure[];
  suggestedFiles: string[];
  organizationRule: OrganizationRule;
  confidence: number;
}

interface OrganizationRule {
  type: OrganizationType;
  criteria: OrganizationCriteria;
  template: OrganizationTemplate;
  priority: number;
}

enum OrganizationType {
  BY_CATEGORY = 'by-category',
  BY_DATE = 'by-date',
  BY_PROJECT = 'by-project',
  BY_SOURCE = 'by-source',
  BY_IMPORTANCE = 'by-importance',
  CUSTOM = 'custom'
}

class FolderOrganizationEngine {
  async generateFolderStructure(
    documents: DocumentAnalysis[],
    organizationType: OrganizationType,
    existingStructure?: FolderStructure
  ): Promise<FolderStructure> {
    
    const organizer = this.getOrganizer(organizationType);
    const structure = await organizer.organize(documents, existingStructure);
    
    // 验证和优化结构
    return this.optimizeStructure(structure);
  }
  
  private getOrganizer(type: OrganizationType): FolderOrganizer {
    switch (type) {
      case OrganizationType.BY_CATEGORY:
        return new CategoryBasedOrganizer();
      case OrganizationType.BY_DATE:
        return new DateBasedOrganizer();
      case OrganizationType.BY_PROJECT:
        return new ProjectBasedOrganizer();
      default:
        return new CategoryBasedOrganizer();
    }
  }
}
```
[Source: architecture.md#components]

### 分类组织器
```typescript
class CategoryBasedOrganizer implements FolderOrganizer {
  async organize(documents: DocumentAnalysis[], existing?: FolderStructure): Promise<FolderStructure> {
    const categoryGroups = this.groupByCategory(documents);
    const rootFolder: FolderStructure = {
      id: 'root',
      name: '文档库',
      path: '/',
      level: 0,
      children: [],
      suggestedFiles: [],
      organizationRule: {
        type: OrganizationType.BY_CATEGORY,
        criteria: { groupBy: 'category' },
        template: this.getCategoryTemplate(),
        priority: 1
      },
      confidence: 0.8
    };
    
    // 创建一级分类文件夹
    for (const [category, docs] of categoryGroups) {
      const categoryFolder = this.createCategoryFolder(category, docs, rootFolder);
      rootFolder.children.push(categoryFolder);
      
      // 如果文档数量较多，创建二级分类
      if (docs.length > 10) {
        const subGroups = this.createSubGroups(docs);
        for (const [subCategory, subDocs] of subGroups) {
          const subFolder = this.createSubCategoryFolder(subCategory, subDocs, categoryFolder);
          categoryFolder.children.push(subFolder);
        }
      }
    }
    
    return rootFolder;
  }
  
  private groupByCategory(documents: DocumentAnalysis[]): Map<string, DocumentAnalysis[]> {
    const groups = new Map<string, DocumentAnalysis[]>();
    
    documents.forEach(doc => {
      const category = this.translateCategory(doc.classification.category);
      if (!groups.has(category)) {
        groups.set(category, []);
      }
      groups.get(category)!.push(doc);
    });
    
    return groups;
  }
  
  private translateCategory(category: string): string {
    const categoryMap: Record<string, string> = {
      'contract': '合同协议',
      'invoice': '发票票据',
      'report': '报告文档',
      'resume': '简历档案',
      'manual': '说明手册',
      'presentation': '演示文稿',
      'academic': '学术资料',
      'legal': '法律文件',
      'financial': '财务资料'
    };
    
    return categoryMap[category] || '其他文档';
  }
}
```
[Source: architecture.md#components]

### 日期组织器
```typescript
class DateBasedOrganizer implements FolderOrganizer {
  async organize(documents: DocumentAnalysis[]): Promise<FolderStructure> {
    const dateGroups = this.groupByDate(documents);
    const rootFolder = this.createRootFolder(OrganizationType.BY_DATE);
    
    // 按年份分组
    const yearGroups = this.groupByYear(dateGroups);
    
    for (const [year, yearDocs] of yearGroups) {
      const yearFolder = this.createYearFolder(year, rootFolder);
      rootFolder.children.push(yearFolder);
      
      // 按月份分组
      const monthGroups = this.groupByMonth(yearDocs);
      for (const [month, monthDocs] of monthGroups) {
        const monthFolder = this.createMonthFolder(year, month, yearFolder);
        yearFolder.children.push(monthFolder);
        
        // 如果单月文档过多，按类型进一步分组
        if (monthDocs.length > 20) {
          const categoryGroups = this.groupByCategory(monthDocs);
          for (const [category, categoryDocs] of categoryGroups) {
            const categoryFolder = this.createCategoryFolder(category, monthFolder);
            monthFolder.children.push(categoryFolder);
            categoryFolder.suggestedFiles = categoryDocs.map(doc => doc.documentId);
          }
        } else {
          monthFolder.suggestedFiles = monthDocs.map(doc => doc.documentId);
        }
      }
    }
    
    return rootFolder;
  }
  
  private groupByDate(documents: DocumentAnalysis[]): Map<string, DocumentAnalysis[]> {
    const groups = new Map<string, DocumentAnalysis[]>();
    
    documents.forEach(doc => {
      const date = this.extractDate(doc);
      const dateKey = date.toISOString().split('T')[0]; // YYYY-MM-DD
      
      if (!groups.has(dateKey)) {
        groups.set(dateKey, []);
      }
      groups.get(dateKey)!.push(doc);
    });
    
    return groups;
  }
  
  private extractDate(doc: DocumentAnalysis): Date {
    // 优先使用文档创建日期
    if (doc.metadata.creationDate) {
      return doc.metadata.creationDate;
    }
    
    // 其次使用修改日期
    if (doc.metadata.modificationDate) {
      return doc.metadata.modificationDate;
    }
    
    // 最后使用当前日期
    return new Date();
  }
}
```
[Source: architecture.md#components]

### 组织模板系统
```typescript
interface OrganizationTemplate {
  id: string;
  name: string;
  description: string;
  type: OrganizationType;
  structure: TemplateStructure;
  rules: TemplateRule[];
  isBuiltIn: boolean;
  usage: number;
}

interface TemplateStructure {
  levels: TemplateLevel[];
  maxDepth: number;
  namingPattern: string;
}

class OrganizationTemplateManager {
  private templates = new Map<string, OrganizationTemplate>();
  
  constructor() {
    this.initializeBuiltInTemplates();
  }
  
  private initializeBuiltInTemplates(): void {
    // 企业文档模板
    this.templates.set('enterprise', {
      id: 'enterprise',
      name: '企业文档管理',
      description: '适用于企业日常文档管理的标准结构',
      type: OrganizationType.BY_CATEGORY,
      structure: {
        levels: [
          { name: '部门', pattern: '{department}' },
          { name: '类型', pattern: '{category}' },
          { name: '年份', pattern: '{year}年' }
        ],
        maxDepth: 3,
        namingPattern: '{department}/{category}/{year}年'
      },
      rules: [
        { field: 'department', source: 'metadata.department', fallback: '通用部门' },
        { field: 'category', source: 'classification.category', fallback: '其他' },
        { field: 'year', source: 'metadata.creationDate.year', fallback: new Date().getFullYear() }
      ],
      isBuiltIn: true,
      usage: 0
    });
    
    // 个人文档模板
    this.templates.set('personal', {
      id: 'personal',
      name: '个人文档整理',
      description: '适用于个人文档收集和整理',
      type: OrganizationType.BY_DATE,
      structure: {
        levels: [
          { name: '年份', pattern: '{year}年' },
          { name: '月份', pattern: '{month}月' },
          { name: '类型', pattern: '{category}' }
        ],
        maxDepth: 3,
        namingPattern: '{year}年/{month}月/{category}'
      },
      rules: [
        { field: 'year', source: 'metadata.creationDate.year', fallback: new Date().getFullYear() },
        { field: 'month', source: 'metadata.creationDate.month', fallback: new Date().getMonth() + 1 },
        { field: 'category', source: 'classification.category', fallback: '未分类' }
      ],
      isBuiltIn: true,
      usage: 0
    });
    
    // 项目文档模板
    this.templates.set('project', {
      id: 'project',
      name: '项目文档管理',
      description: '按项目组织文档，适用于项目管理场景',
      type: OrganizationType.BY_PROJECT,
      structure: {
        levels: [
          { name: '项目', pattern: '{project}' },
          { name: '阶段', pattern: '{phase}' },
          { name: '类型', pattern: '{doctype}' }
        ],
        maxDepth: 3,
        namingPattern: '{project}/{phase}/{doctype}'
      },
      rules: [
        { field: 'project', source: 'content.keywords.project', fallback: '默认项目' },
        { field: 'phase', source: 'content.keywords.phase', fallback: '通用' },
        { field: 'doctype', source: 'classification.category', fallback: '文档' }
      ],
      isBuiltIn: true,
      usage: 0
    });
  }
  
  applyTemplate(template: OrganizationTemplate, documents: DocumentAnalysis[]): FolderStructure {
    const organizer = new TemplateBasedOrganizer(template);
    return organizer.organize(documents);
  }
  
  createCustomTemplate(config: TemplateConfig): OrganizationTemplate {
    const template: OrganizationTemplate = {
      id: this.generateTemplateId(),
      name: config.name,
      description: config.description,
      type: config.type,
      structure: config.structure,
      rules: config.rules,
      isBuiltIn: false,
      usage: 0
    };
    
    this.templates.set(template.id, template);
    return template;
  }
}
```
[Source: architecture.md#components]

### 拖拽整理功能
```typescript
interface DragDropState {
  isDragging: boolean;
  draggedFiles: string[];
  dropTarget?: FolderStructure;
  dragPreview?: DragPreview;
}

class DragDropOrganizer {
  private state: DragDropState = {
    isDragging: false,
    draggedFiles: []
  };
  
  startDrag(fileIds: string[], event: DragEvent): void {
    this.state = {
      isDragging: true,
      draggedFiles: fileIds,
      dragPreview: this.createDragPreview(fileIds)
    };
    
    // 设置拖拽数据
    event.dataTransfer?.setData('application/json', JSON.stringify({
      type: 'pdf-files',
      fileIds
    }));
    
    // 设置拖拽效果
    event.dataTransfer!.effectAllowed = 'move';
    
    // 添加拖拽样式
    this.addDragStyles();
  }
  
  handleDragOver(folder: FolderStructure, event: DragEvent): void {
    event.preventDefault();
    
    // 检查是否可以接受拖拽
    if (this.canAcceptDrop(folder)) {
      event.dataTransfer!.dropEffect = 'move';
      this.highlightDropTarget(folder);
    } else {
      event.dataTransfer!.dropEffect = 'none';
    }
  }
  
  async handleDrop(folder: FolderStructure, event: DragEvent): Promise<void> {
    event.preventDefault();
    
    try {
      const dragData = JSON.parse(event.dataTransfer?.getData('application/json') || '{}');
      
      if (dragData.type === 'pdf-files' && this.canAcceptDrop(folder)) {
        await this.moveFilesToFolder(dragData.fileIds, folder);
        this.showDropSuccess(dragData.fileIds.length, folder);
      }
    } catch (error) {
      this.showDropError(error.message);
    } finally {
      this.endDrag();
    }
  }
  
  private async moveFilesToFolder(fileIds: string[], targetFolder: FolderStructure): Promise<void> {
    const moveOperations = fileIds.map(fileId => ({
      fileId,
      sourcePath: this.getFilePath(fileId),
      targetPath: this.buildTargetPath(targetFolder, fileId)
    }));
    
    // 检查路径冲突
    const conflicts = this.detectPathConflicts(moveOperations);
    if (conflicts.length > 0) {
      await this.resolveConflicts(conflicts);
    }
    
    // 执行移动操作
    for (const operation of moveOperations) {
      await this.fileSystem.moveFile(operation.sourcePath, operation.targetPath);
    }
    
    // 更新文件夹结构
    targetFolder.suggestedFiles.push(...fileIds);
  }
  
  private canAcceptDrop(folder: FolderStructure): boolean {
    // 检查文件夹深度限制
    if (folder.level >= 3) return false;
    
    // 检查组织规则兼容性
    if (!this.isCompatibleWithRule(folder.organizationRule)) return false;
    
    return true;
  }
}
```
[Source: architecture.md#components]

### 批量整理管理
```typescript
interface BatchOrganizeOperation {
  id: string;
  files: string[];
  targetStructure: FolderStructure;
  template: OrganizationTemplate;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  progress: BatchProgress;
  results: OrganizeResult[];
}

interface BatchProgress {
  total: number;
  processed: number;
  successful: number;
  failed: number;
  percentage: number;
}

class BatchOrganizeManager {
  private operations = new Map<string, BatchOrganizeOperation>();
  
  async createBatchOperation(
    fileIds: string[],
    template: OrganizationTemplate
  ): Promise<string> {
    const operationId = this.generateOperationId();
    
    // 分析文件并生成目标结构
    const documents = await this.loadDocuments(fileIds);
    const targetStructure = await this.templateManager.applyTemplate(template, documents);
    
    const operation: BatchOrganizeOperation = {
      id: operationId,
      files: fileIds,
      targetStructure,
      template,
      status: 'pending',
      progress: {
        total: fileIds.length,
        processed: 0,
        successful: 0,
        failed: 0,
        percentage: 0
      },
      results: []
    };
    
    this.operations.set(operationId, operation);
    return operationId;
  }
  
  async executeBatchOrganize(operationId: string): Promise<void> {
    const operation = this.operations.get(operationId);
    if (!operation) throw new Error('操作不存在');
    
    operation.status = 'processing';
    
    try {
      // 创建文件夹结构
      await this.createFolderStructure(operation.targetStructure);
      
      // 逐个处理文件
      for (const fileId of operation.files) {
        try {
          const result = await this.organizeFile(fileId, operation.targetStructure);
          operation.results.push(result);
          
          if (result.success) {
            operation.progress.successful++;
          } else {
            operation.progress.failed++;
          }
        } catch (error) {
          operation.results.push({
            fileId,
            success: false,
            error: error.message,
            targetPath: ''
          });
          operation.progress.failed++;
        }
        
        // 更新进度
        operation.progress.processed++;
        operation.progress.percentage = (operation.progress.processed / operation.progress.total) * 100;
        
        // 通知进度更新
        this.notifyProgress(operationId, operation.progress);
      }
      
      operation.status = 'completed';
    } catch (error) {
      operation.status = 'failed';
      throw error;
    }
  }
  
  private async organizeFile(fileId: string, structure: FolderStructure): Promise<OrganizeResult> {
    const document = await this.documentService.getDocument(fileId);
    const analysis = await this.analysisService.getAnalysis(fileId);
    
    // 找到最适合的文件夹
    const targetFolder = this.findBestFolder(analysis, structure);
    
    if (!targetFolder) {
      throw new Error('无法找到合适的目标文件夹');
    }
    
    // 构建目标路径
    const targetPath = this.buildFilePath(targetFolder, document.fileName);
    
    // 移动文件
    await this.fileSystem.moveFile(document.filePath, targetPath);
    
    return {
      fileId,
      success: true,
      targetPath,
      targetFolder: targetFolder.name
    };
  }
}
```
[Source: architecture.md#components]

### 性能优化
- **异步处理**: 使用Web Worker进行大批量文件分析
- **增量更新**: 只重新分析修改的文件夹结构
- **缓存策略**: 缓存文件夹建议和组织结果
- **虚拟滚动**: 大量文件夹时使用虚拟滚动优化渲染
[Source: architecture.md#performance-optimization]

### Testing
**测试文件位置**: `tests/renderer/services/FolderOrganizationEngine.test.ts`
**测试框架**: Jest + File System Mock
**关键测试场景**:
- 各种组织模板的结构生成测试
- 拖拽整理功能完整性测试
- 批量整理操作可靠性测试
- 文件夹深度限制验证测试
- 路径冲突处理测试
**测试标准**:
- 文件夹建议准确率≥75%
- 批量整理成功率≥90%
- 拖拽操作响应时间<200ms
- 文件夹结构合规性100%
- 路径冲突检测准确率100%
[Source: architecture.md#testing-strategy]

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-21 | v1.0 | 初始故事创建 | Bob (SM) |

## Dev Agent Record
*此部分将在开发实施过程中由开发代理填充*

### Agent Model Used
*待填充*

### Debug Log References
*待填充*

### Completion Notes List
*待填充*

### File List
*待填充*

## QA Results
*此部分将在QA代理审查完成后填充*