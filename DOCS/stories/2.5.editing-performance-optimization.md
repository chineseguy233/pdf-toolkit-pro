# Story 2.5: 编辑性能优化

## Status
Completed - 2025-08-22

## Story
**As a** 用户,
**I want** 编辑操作响应迅速,
**so that** 我能够流畅地进行文档编辑工作

## Acceptance Criteria
1. 文本编辑响应时间小于50ms
2. 大文档（50页以上）编辑性能不降级
3. 内存使用优化，避免内存泄漏
4. 支持多个文本区域同时编辑
5. 编辑操作不影响其他功能的性能
6. 在低配置设备上保持可用性能

## Tasks / Subtasks
- [ ] 实现编辑响应优化 (AC: 1)
  - [ ] 优化文本定位算法性能
  - [ ] 实现编辑事件防抖和节流
  - [ ] 使用虚拟DOM减少重渲染
  - [ ] 优化Canvas绘制性能
- [ ] 大文档性能优化 (AC: 2)
  - [ ] 实现页面级别的懒加载
  - [ ] 优化文本层解析缓存策略
  - [ ] 使用Web Worker处理重计算
  - [ ] 实现增量渲染机制
- [ ] 内存管理优化 (AC: 3)
  - [ ] 实现对象池管理文本块
  - [ ] 优化事件监听器生命周期
  - [ ] 清理未使用的Canvas缓存
  - [ ] 监控和修复内存泄漏
- [ ] 并发编辑支持 (AC: 4)
  - [ ] 实现多编辑器状态管理
  - [ ] 优化编辑冲突检测
  - [ ] 实现编辑队列管理
  - [ ] 添加编辑锁定机制
- [ ] 系统性能隔离 (AC: 5)
  - [ ] 使用RequestAnimationFrame优化渲染
  - [ ] 实现任务优先级调度
  - [ ] 分离编辑和预览渲染线程
  - [ ] 优化CPU密集型操作
- [ ] 低配置设备适配 (AC: 6)
  - [ ] 实现性能检测和降级
  - [ ] 优化低端设备的渲染策略
  - [ ] 减少不必要的动画效果
  - [ ] 提供性能模式选项

## Dev Notes

### 性能监控架构
```typescript
interface PerformanceMetrics {
  editingLatency: number;        // 编辑延迟
  renderingTime: number;         // 渲染时间
  memoryUsage: number;          // 内存使用量
  cpuUsage: number;             // CPU使用率
  frameRate: number;            // 帧率
}

class PerformanceMonitor {
  private metrics: PerformanceMetrics = {
    editingLatency: 0,
    renderingTime: 0,
    memoryUsage: 0,
    cpuUsage: 0,
    frameRate: 60
  };
  
  measureEditingLatency<T>(operation: () => T): T {
    const startTime = performance.now();
    const result = operation();
    const endTime = performance.now();
    
    this.metrics.editingLatency = endTime - startTime;
    
    if (this.metrics.editingLatency > 50) {
      console.warn(`编辑操作延迟过高: ${this.metrics.editingLatency}ms`);
    }
    
    return result;
  }
  
  trackMemoryUsage(): void {
    if ('memory' in performance) {
      const memory = (performance as any).memory;
      this.metrics.memoryUsage = memory.usedJSHeapSize / 1024 / 1024; // MB
      
      if (this.metrics.memoryUsage > 200) {
        this.triggerGarbageCollection();
      }
    }
  }
}
```
[Source: architecture.md#monitoring-and-observability]

### 编辑响应优化
```typescript
class OptimizedEditingEngine {
  private editingQueue: EditOperation[] = [];
  private isProcessing = false;
  private debounceTimer: NodeJS.Timeout | null = null;
  
  queueEdit(operation: EditOperation): void {
    this.editingQueue.push(operation);
    this.scheduleProcessing();
  }
  
  private scheduleProcessing(): void {
    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer);
    }
    
    this.debounceTimer = setTimeout(() => {
      this.processEditQueue();
    }, 16); // ~60fps
  }
  
  private async processEditQueue(): Promise<void> {
    if (this.isProcessing || this.editingQueue.length === 0) {
      return;
    }
    
    this.isProcessing = true;
    
    try {
      // 批量处理编辑操作
      const operations = this.editingQueue.splice(0);
      await this.batchProcessOperations(operations);
    } finally {
      this.isProcessing = false;
    }
  }
  
  private async batchProcessOperations(operations: EditOperation[]): Promise<void> {
    // 合并相同文本块的操作
    const mergedOps = this.mergeOperations(operations);
    
    // 使用RequestAnimationFrame确保不阻塞UI
    return new Promise(resolve => {
      requestAnimationFrame(async () => {
        for (const op of mergedOps) {
          await this.executeOperation(op);
        }
        resolve();
      });
    });
  }
}
```
[Source: architecture.md#performance-optimization]

### 大文档优化策略
```typescript
class LargeDocumentOptimizer {
  private pageCache = new Map<number, PageData>();
  private visiblePages = new Set<number>();
  private renderingWorker: Worker;
  
  constructor() {
    this.renderingWorker = new Worker('/workers/pdf-renderer.js');
  }
  
  async optimizeForLargeDocument(document: PDFDocument): Promise<void> {
    if (document.pageCount > 50) {
      // 启用大文档优化模式
      this.enableLargeDocumentMode();
      
      // 预加载可见页面
      await this.preloadVisiblePages();
      
      // 设置虚拟滚动
      this.setupVirtualScrolling();
    }
  }
  
  private enableLargeDocumentMode(): void {
    // 减少缓存页面数量
    this.maxCachedPages = 10;
    
    // 降低渲染质量
    this.renderingQuality = 'medium';
    
    // 启用增量渲染
    this.incrementalRendering = true;
  }
  
  async renderPageInWorker(pageNumber: number): Promise<ImageData> {
    return new Promise((resolve, reject) => {
      this.renderingWorker.postMessage({
        type: 'render-page',
        pageNumber,
        quality: this.renderingQuality
      });
      
      this.renderingWorker.onmessage = (event) => {
        if (event.data.type === 'page-rendered') {
          resolve(event.data.imageData);
        }
      };
      
      this.renderingWorker.onerror = reject;
    });
  }
}
```
[Source: architecture.md#performance-optimization]

### 内存管理系统
```typescript
class MemoryManager {
  private objectPools = new Map<string, ObjectPool>();
  private memoryThreshold = 150; // MB
  private cleanupInterval: NodeJS.Timeout;
  
  constructor() {
    this.setupObjectPools();
    this.startMemoryMonitoring();
  }
  
  private setupObjectPools(): void {
    // 文本块对象池
    this.objectPools.set('textBlock', new ObjectPool(() => ({
      id: '',
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      text: '',
      fontFamily: '',
      fontSize: 12,
      color: '#000000'
    }), 100));
    
    // Canvas对象池
    this.objectPools.set('canvas', new ObjectPool(() => {
      const canvas = document.createElement('canvas');
      canvas.width = 800;
      canvas.height = 600;
      return canvas;
    }, 10));
  }
  
  getObject<T>(poolName: string): T {
    const pool = this.objectPools.get(poolName);
    return pool ? pool.acquire() : null;
  }
  
  returnObject(poolName: string, obj: any): void {
    const pool = this.objectPools.get(poolName);
    if (pool) {
      pool.release(obj);
    }
  }
  
  private startMemoryMonitoring(): void {
    this.cleanupInterval = setInterval(() => {
      this.checkMemoryUsage();
    }, 5000);
  }
  
  private checkMemoryUsage(): void {
    const memoryUsage = this.getCurrentMemoryUsage();
    
    if (memoryUsage > this.memoryThreshold) {
      this.performCleanup();
    }
  }
  
  private performCleanup(): void {
    // 清理缓存
    this.clearOldCaches();
    
    // 释放未使用的对象
    this.releaseUnusedObjects();
    
    // 强制垃圾回收（如果可用）
    if ('gc' in window) {
      (window as any).gc();
    }
  }
}
```
[Source: architecture.md#performance-optimization]

### 并发编辑管理
```typescript
class ConcurrentEditingManager {
  private activeEditors = new Map<string, EditorState>();
  private editingLocks = new Set<string>();
  
  startEditing(textBlockId: string, editorId: string): boolean {
    // 检查是否已被锁定
    if (this.editingLocks.has(textBlockId)) {
      return false;
    }
    
    // 锁定文本块
    this.editingLocks.add(textBlockId);
    
    // 记录编辑器状态
    this.activeEditors.set(editorId, {
      textBlockId,
      startTime: Date.now(),
      isActive: true
    });
    
    return true;
  }
  
  finishEditing(editorId: string): void {
    const editorState = this.activeEditors.get(editorId);
    if (editorState) {
      // 释放锁定
      this.editingLocks.delete(editorState.textBlockId);
      
      // 清理编辑器状态
      this.activeEditors.delete(editorId);
    }
  }
  
  resolveEditingConflict(textBlockId: string): void {
    // 找到所有编辑该文本块的编辑器
    const conflictingEditors = Array.from(this.activeEditors.entries())
      .filter(([_, state]) => state.textBlockId === textBlockId);
    
    if (conflictingEditors.length > 1) {
      // 保留最早开始编辑的编辑器
      const earliestEditor = conflictingEditors
        .sort((a, b) => a[1].startTime - b[1].startTime)[0];
      
      // 取消其他编辑器
      conflictingEditors
        .filter(([id]) => id !== earliestEditor[0])
        .forEach(([id]) => this.cancelEditing(id));
    }
  }
}
```
[Source: architecture.md#components]

### 性能降级策略
```typescript
class PerformanceDegradation {
  private deviceCapability: DeviceCapability;
  
  constructor() {
    this.deviceCapability = this.detectDeviceCapability();
  }
  
  private detectDeviceCapability(): DeviceCapability {
    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl');
    
    return {
      memory: this.getAvailableMemory(),
      cpuCores: navigator.hardwareConcurrency || 2,
      hasWebGL: !!gl,
      maxTextureSize: gl ? gl.getParameter(gl.MAX_TEXTURE_SIZE) : 2048,
      isLowEnd: this.isLowEndDevice()
    };
  }
  
  private isLowEndDevice(): boolean {
    const memory = this.getAvailableMemory();
    const cores = navigator.hardwareConcurrency || 2;
    
    return memory < 4096 || cores < 4; // 4GB内存或4核心以下
  }
  
  applyPerformanceSettings(): PerformanceSettings {
    if (this.deviceCapability.isLowEnd) {
      return {
        renderingQuality: 'low',
        maxCachedPages: 5,
        animationsEnabled: false,
        webWorkerEnabled: false,
        incrementalRendering: true
      };
    } else {
      return {
        renderingQuality: 'high',
        maxCachedPages: 20,
        animationsEnabled: true,
        webWorkerEnabled: true,
        incrementalRendering: false
      };
    }
  }
}
```
[Source: architecture.md#performance-optimization]

### 渲染优化
```typescript
class OptimizedRenderer {
  private renderingScheduler: RenderingScheduler;
  private frameBuffer: OffscreenCanvas;
  
  constructor() {
    this.renderingScheduler = new RenderingScheduler();
    this.frameBuffer = new OffscreenCanvas(800, 600);
  }
  
  scheduleRender(renderTask: RenderTask): void {
    this.renderingScheduler.schedule(renderTask);
  }
  
  optimizedRender(elements: RenderElement[]): void {
    // 使用双缓冲减少闪烁
    const offscreenCtx = this.frameBuffer.getContext('2d')!;
    
    // 批量渲染元素
    this.batchRender(offscreenCtx, elements);
    
    // 一次性绘制到主Canvas
    requestAnimationFrame(() => {
      this.copyToMainCanvas();
    });
  }
  
  private batchRender(ctx: OffscreenCanvasRenderingContext2D, elements: RenderElement[]): void {
    // 按层级排序
    elements.sort((a, b) => a.zIndex - b.zIndex);
    
    // 批量设置样式
    const styleGroups = this.groupByStyle(elements);
    
    for (const [style, groupElements] of styleGroups) {
      this.applyStyle(ctx, style);
      groupElements.forEach(element => {
        this.renderElement(ctx, element);
      });
    }
  }
}
```
[Source: architecture.md#components]

### Testing
**测试文件位置**: `tests/renderer/performance/EditingPerformance.test.ts`
**测试框架**: Jest + Performance API + Memory Profiler
**关键测试场景**:
- 编辑响应时间基准测试
- 大文档性能压力测试
- 内存泄漏检测测试
- 并发编辑性能测试
- 低配置设备模拟测试
**测试标准**:
- 编辑响应时间<50ms
- 大文档性能不降级>20%
- 无内存泄漏
- 并发编辑支持≥5个
- 低配置设备可用性≥80%
[Source: architecture.md#testing-strategy]

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-21 | v1.0 | 初始故事创建 | Bob (SM) |

## Dev Agent Record
*此部分将在开发实施过程中由开发代理填充*

### Agent Model Used
*待填充*

### Debug Log References
*待填充*

### Completion Notes List
*待填充*

### File List
*待填充*

## QA Results
*此部分将在QA代理审查完成后填充*