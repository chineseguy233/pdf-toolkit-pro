# Story 4.2: 批量处理自动化

## Status
Draft

## Story
**As a** 用户,
**I want** 系统能够批量处理多个PDF文件并自动执行各种操作,
**so that** 我能够高效处理大量文档而无需逐个手动操作

## Acceptance Criteria
1. 支持批量导入和处理多个PDF文件
2. 提供预定义的批量操作模板（重命名、分类、OCR等）
3. 支持自定义批量处理工作流
4. 实时显示批量处理进度和状态
5. 提供详细的处理结果报告
6. 支持处理失败的重试和错误恢复

## Tasks / Subtasks
- [ ] 实现批量文件导入 (AC: 1)
  - [ ] 支持文件夹拖拽批量导入
  - [ ] 实现文件格式过滤和验证
  - [ ] 添加导入进度显示
  - [ ] 处理大量文件的内存优化
- [ ] 开发批量操作模板 (AC: 2)
  - [ ] 创建预定义操作模板
  - [ ] 实现模板参数配置
  - [ ] 添加模板保存和加载功能
  - [ ] 支持模板分享和导入
- [ ] 创建工作流编辑器 (AC: 3)
  - [ ] 设计可视化工作流编辑界面
  - [ ] 实现拖拽式操作组合
  - [ ] 添加条件分支和循环逻辑
  - [ ] 支持工作流验证和测试
- [ ] 实现进度监控系统 (AC: 4)
  - [ ] 创建实时进度显示组件
  - [ ] 实现任务状态跟踪
  - [ ] 添加处理速度和剩余时间估算
  - [ ] 支持处理暂停和恢复
- [ ] 开发结果报告功能 (AC: 5)
  - [ ] 生成详细的处理结果统计
  - [ ] 创建可视化报告界面
  - [ ] 支持报告导出和分享
  - [ ] 添加历史记录查询
- [ ] 实现错误处理机制 (AC: 6)
  - [ ] 添加智能重试策略
  - [ ] 实现错误分类和处理
  - [ ] 创建错误恢复向导
  - [ ] 支持部分成功结果保存

## Dev Notes

### 批量处理架构
```typescript
interface BatchJob {
  id: string;
  name: string;
  files: BatchFile[];
  workflow: ProcessingWorkflow;
  status: BatchJobStatus;
  progress: BatchProgress;
  results: BatchResult[];
  createdAt: Date;
  startedAt?: Date;
  completedAt?: Date;
}

interface BatchFile {
  id: string;
  filePath: string;
  fileName: string;
  fileSize: number;
  status: FileProcessingStatus;
  progress: number;
  error?: ProcessingError;
  result?: FileProcessingResult;
}

enum BatchJobStatus {
  PENDING = 'pending',
  RUNNING = 'running',
  PAUSED = 'paused',
  COMPLETED = 'completed',
  FAILED = 'failed',
  CANCELLED = 'cancelled'
}

enum FileProcessingStatus {
  WAITING = 'waiting',
  PROCESSING = 'processing',
  COMPLETED = 'completed',
  FAILED = 'failed',
  SKIPPED = 'skipped'
}

class BatchProcessingEngine {
  private activeJobs = new Map<string, BatchJob>();
  private jobQueue: string[] = [];
  private maxConcurrentJobs = 3;
  
  async createBatchJob(
    files: string[],
    workflow: ProcessingWorkflow,
    name?: string
  ): Promise<string> {
    const jobId = this.generateJobId();
    
    const batchFiles: BatchFile[] = files.map(filePath => ({
      id: this.generateFileId(),
      filePath,
      fileName: path.basename(filePath),
      fileSize: this.getFileSize(filePath),
      status: FileProcessingStatus.WAITING,
      progress: 0
    }));
    
    const job: BatchJob = {
      id: jobId,
      name: name || `批量处理任务_${new Date().toLocaleString()}`,
      files: batchFiles,
      workflow,
      status: BatchJobStatus.PENDING,
      progress: {
        totalFiles: files.length,
        processedFiles: 0,
        successfulFiles: 0,
        failedFiles: 0,
        percentage: 0
      },
      results: [],
      createdAt: new Date()
    };
    
    this.activeJobs.set(jobId, job);
    return jobId;
  }
  
  async executeBatchJob(jobId: string): Promise<void> {
    const job = this.activeJobs.get(jobId);
    if (!job) throw new Error('批量任务不存在');
    
    job.status = BatchJobStatus.RUNNING;
    job.startedAt = new Date();
    
    try {
      await this.processJobFiles(job);
      job.status = BatchJobStatus.COMPLETED;
      job.completedAt = new Date();
    } catch (error) {
      job.status = BatchJobStatus.FAILED;
      throw error;
    }
  }
  
  private async processJobFiles(job: BatchJob): Promise<void> {
    const concurrentLimit = Math.min(this.maxConcurrentJobs, job.files.length);
    const processingQueue = [...job.files];
    const activeProcessing: Promise<void>[] = [];
    
    while (processingQueue.length > 0 || activeProcessing.length > 0) {
      // 启动新的处理任务
      while (activeProcessing.length < concurrentLimit && processingQueue.length > 0) {
        const file = processingQueue.shift()!;
        const processingPromise = this.processFile(job, file);
        activeProcessing.push(processingPromise);
      }
      
      // 等待任意一个任务完成
      await Promise.race(activeProcessing);
      
      // 移除已完成的任务
      for (let i = activeProcessing.length - 1; i >= 0; i--) {
        if (await this.isPromiseResolved(activeProcessing[i])) {
          activeProcessing.splice(i, 1);
        }
      }
      
      // 更新整体进度
      this.updateJobProgress(job);
    }
  }
}
```
[Source: architecture.md#components]

### 工作流定义系统
```typescript
interface ProcessingWorkflow {
  id: string;
  name: string;
  description: string;
  steps: WorkflowStep[];
  conditions: WorkflowCondition[];
  isTemplate: boolean;
}

interface WorkflowStep {
  id: string;
  type: StepType;
  name: string;
  parameters: Record<string, any>;
  order: number;
  isEnabled: boolean;
  onError: ErrorHandlingStrategy;
}

enum StepType {
  ANALYZE_CONTENT = 'analyze-content',
  EXTRACT_TEXT = 'extract-text',
  OCR_RECOGNITION = 'ocr-recognition',
  SMART_RENAME = 'smart-rename',
  CATEGORIZE = 'categorize',
  ORGANIZE_FOLDERS = 'organize-folders',
  DETECT_DUPLICATES = 'detect-duplicates',
  CUSTOM_SCRIPT = 'custom-script'
}

enum ErrorHandlingStrategy {
  STOP_JOB = 'stop-job',
  SKIP_FILE = 'skip-file',
  RETRY = 'retry',
  CONTINUE = 'continue'
}

class WorkflowEngine {
  private stepProcessors = new Map<StepType, StepProcessor>();
  
  constructor() {
    this.initializeStepProcessors();
  }
  
  async executeWorkflow(workflow: ProcessingWorkflow, file: BatchFile): Promise<FileProcessingResult> {
    const result: FileProcessingResult = {
      fileId: file.id,
      steps: [],
      success: true,
      errors: []
    };
    
    for (const step of workflow.steps.filter(s => s.isEnabled).sort((a, b) => a.order - b.order)) {
      try {
        file.status = FileProcessingStatus.PROCESSING;
        
        const stepResult = await this.executeStep(step, file);
        result.steps.push(stepResult);
        
        // 检查条件分支
        if (!this.evaluateConditions(workflow.conditions, stepResult)) {
          break;
        }
        
      } catch (error) {
        const stepError: ProcessingError = {
          step: step.name,
          message: error.message,
          timestamp: new Date()
        };
        
        result.errors.push(stepError);
        
        // 根据错误处理策略决定后续操作
        const shouldContinue = await this.handleStepError(step, error, file);
        if (!shouldContinue) {
          result.success = false;
          break;
        }
      }
    }
    
    file.status = result.success ? FileProcessingStatus.COMPLETED : FileProcessingStatus.FAILED;
    return result;
  }
  
  private async executeStep(step: WorkflowStep, file: BatchFile): Promise<StepResult> {
    const processor = this.stepProcessors.get(step.type);
    if (!processor) {
      throw new Error(`不支持的步骤类型: ${step.type}`);
    }
    
    const startTime = Date.now();
    const result = await processor.process(file, step.parameters);
    const endTime = Date.now();
    
    return {
      stepId: step.id,
      stepName: step.name,
      success: true,
      duration: endTime - startTime,
      output: result
    };
  }
  
  private initializeStepProcessors(): void {
    this.stepProcessors.set(StepType.ANALYZE_CONTENT, new ContentAnalysisProcessor());
    this.stepProcessors.set(StepType.EXTRACT_TEXT, new TextExtractionProcessor());
    this.stepProcessors.set(StepType.OCR_RECOGNITION, new OCRProcessor());
    this.stepProcessors.set(StepType.SMART_RENAME, new SmartRenameProcessor());
    this.stepProcessors.set(StepType.CATEGORIZE, new CategorizationProcessor());
    this.stepProcessors.set(StepType.ORGANIZE_FOLDERS, new FolderOrganizationProcessor());
    this.stepProcessors.set(StepType.DETECT_DUPLICATES, new DuplicateDetectionProcessor());
  }
}
```
[Source: architecture.md#components]

### 预定义模板系统
```typescript
class BatchTemplateManager {
  private templates = new Map<string, ProcessingWorkflow>();
  
  constructor() {
    this.initializeBuiltInTemplates();
  }
  
  private initializeBuiltInTemplates(): void {
    // 智能整理模板
    this.templates.set('smart-organize', {
      id: 'smart-organize',
      name: '智能文档整理',
      description: '分析文档内容，智能重命名并按类型组织到文件夹',
      steps: [
        {
          id: 'analyze',
          type: StepType.ANALYZE_CONTENT,
          name: '内容分析',
          parameters: { includeOCR: false },
          order: 1,
          isEnabled: true,
          onError: ErrorHandlingStrategy.SKIP_FILE
        },
        {
          id: 'rename',
          type: StepType.SMART_RENAME,
          name: '智能重命名',
          parameters: { 
            strategy: 'date-category-title',
            maxLength: 100 
          },
          order: 2,
          isEnabled: true,
          onError: ErrorHandlingStrategy.CONTINUE
        },
        {
          id: 'organize',
          type: StepType.ORGANIZE_FOLDERS,
          name: '文件夹整理',
          parameters: { 
            template: 'enterprise',
            createSubfolders: true 
          },
          order: 3,
          isEnabled: true,
          onError: ErrorHandlingStrategy.CONTINUE
        }
      ],
      conditions: [],
      isTemplate: true
    });
    
    // OCR批量识别模板
    this.templates.set('batch-ocr', {
      id: 'batch-ocr',
      name: '批量OCR识别',
      description: '对扫描文档进行OCR文字识别并提取文本',
      steps: [
        {
          id: 'ocr',
          type: StepType.OCR_RECOGNITION,
          name: 'OCR文字识别',
          parameters: { 
            language: 'chi_sim+eng',
            confidence: 0.8 
          },
          order: 1,
          isEnabled: true,
          onError: ErrorHandlingStrategy.RETRY
        },
        {
          id: 'analyze',
          type: StepType.ANALYZE_CONTENT,
          name: '内容分析',
          parameters: { useOCRText: true },
          order: 2,
          isEnabled: true,
          onError: ErrorHandlingStrategy.CONTINUE
        }
      ],
      conditions: [],
      isTemplate: true
    });
    
    // 重复文件清理模板
    this.templates.set('duplicate-cleanup', {
      id: 'duplicate-cleanup',
      name: '重复文件清理',
      description: '检测并清理重复的PDF文件',
      steps: [
        {
          id: 'analyze',
          type: StepType.ANALYZE_CONTENT,
          name: '内容分析',
          parameters: {},
          order: 1,
          isEnabled: true,
          onError: ErrorHandlingStrategy.SKIP_FILE
        },
        {
          id: 'detect-duplicates',
          type: StepType.DETECT_DUPLICATES,
          name: '重复检测',
          parameters: { 
            similarity: 0.95,
            strategy: 'auto-smart' 
          },
          order: 2,
          isEnabled: true,
          onError: ErrorHandlingStrategy.CONTINUE
        }
      ],
      conditions: [],
      isTemplate: true
    });
  }
  
  getTemplate(templateId: string): ProcessingWorkflow | undefined {
    return this.templates.get(templateId);
  }
  
  createCustomTemplate(workflow: ProcessingWorkflow): void {
    workflow.isTemplate = true;
    this.templates.set(workflow.id, workflow);
    this.saveTemplates();
  }
  
  cloneTemplate(templateId: string, newName: string): ProcessingWorkflow {
    const template = this.templates.get(templateId);
    if (!template) throw new Error('模板不存在');
    
    const cloned: ProcessingWorkflow = {
      ...template,
      id: this.generateTemplateId(),
      name: newName,
      isTemplate: false
    };
    
    return cloned;
  }
}
```
[Source: architecture.md#components]

### 可视化工作流编辑器
```typescript
interface WorkflowEditorState {
  workflow: ProcessingWorkflow;
  selectedStep?: WorkflowStep;
  draggedStep?: WorkflowStep;
  isEditing: boolean;
  validationErrors: ValidationError[];
}

class WorkflowEditor extends React.Component<WorkflowEditorProps, WorkflowEditorState> {
  private canvasRef = React.createRef<HTMLCanvasElement>();
  
  state: WorkflowEditorState = {
    workflow: this.createEmptyWorkflow(),
    isEditing: false,
    validationErrors: []
  };
  
  render() {
    return (
      <div className="workflow-editor">
        <div className="editor-toolbar">
          <div className="step-palette">
            <h4>可用步骤</h4>
            {Object.values(StepType).map(stepType => (
              <StepPaletteItem
                key={stepType}
                stepType={stepType}
                onDragStart={this.handleStepDragStart}
              />
            ))}
          </div>
          
          <div className="workflow-actions">
            <button onClick={this.validateWorkflow}>验证工作流</button>
            <button onClick={this.testWorkflow}>测试运行</button>
            <button onClick={this.saveWorkflow}>保存工作流</button>
          </div>
        </div>
        
        <div className="editor-canvas">
          <WorkflowCanvas
            ref={this.canvasRef}
            workflow={this.state.workflow}
            selectedStep={this.state.selectedStep}
            onStepSelect={this.handleStepSelect}
            onStepMove={this.handleStepMove}
            onStepConnect={this.handleStepConnect}
            onDrop={this.handleCanvasDrop}
          />
        </div>
        
        <div className="step-properties">
          {this.state.selectedStep && (
            <StepPropertiesPanel
              step={this.state.selectedStep}
              onChange={this.handleStepPropertiesChange}
            />
          )}
        </div>
        
        {this.state.validationErrors.length > 0 && (
          <div className="validation-errors">
            <h4>验证错误</h4>
            {this.state.validationErrors.map((error, index) => (
              <div key={index} className="error-item">
                {error.message}
              </div>
            ))}
          </div>
        )}
      </div>
    );
  }
  
  private handleCanvasDrop = (event: React.DragEvent, position: { x: number, y: number }): void => {
    const stepType = event.dataTransfer.getData('stepType') as StepType;
    if (!stepType) return;
    
    const newStep: WorkflowStep = {
      id: this.generateStepId(),
      type: stepType,
      name: this.getStepDisplayName(stepType),
      parameters: this.getDefaultParameters(stepType),
      order: this.state.workflow.steps.length + 1,
      isEnabled: true,
      onError: ErrorHandlingStrategy.SKIP_FILE
    };
    
    this.setState(prevState => ({
      workflow: {
        ...prevState.workflow,
        steps: [...prevState.workflow.steps, newStep]
      }
    }));
  };
  
  private validateWorkflow = (): void => {
    const errors: ValidationError[] = [];
    const { workflow } = this.state;
    
    // 检查是否有步骤
    if (workflow.steps.length === 0) {
      errors.push({ message: '工作流至少需要一个步骤' });
    }
    
    // 检查步骤顺序
    const orders = workflow.steps.map(s => s.order);
    const uniqueOrders = new Set(orders);
    if (orders.length !== uniqueOrders.size) {
      errors.push({ message: '步骤顺序不能重复' });
    }
    
    // 检查步骤参数
    workflow.steps.forEach(step => {
      const validator = this.getStepValidator(step.type);
      const stepErrors = validator.validate(step.parameters);
      errors.push(...stepErrors);
    });
    
    this.setState({ validationErrors: errors });
  };
  
  private testWorkflow = async (): Promise<void> => {
    // 使用测试文件运行工作流
    const testFile: BatchFile = {
      id: 'test-file',
      filePath: '/test/sample.pdf',
      fileName: 'sample.pdf',
      fileSize: 1024 * 1024,
      status: FileProcessingStatus.WAITING,
      progress: 0
    };
    
    try {
      const result = await this.workflowEngine.executeWorkflow(this.state.workflow, testFile);
      this.showTestResult(result);
    } catch (error) {
      this.showTestError(error);
    }
  };
}
```
[Source: architecture.md#components]

### 进度监控系统
```typescript
interface BatchProgressMonitor {
  jobId: string;
  totalFiles: number;
  processedFiles: number;
  currentFile?: string;
  estimatedTimeRemaining: number;
  processingSpeed: number; // files per minute
  startTime: Date;
}

class BatchProgressTracker {
  private monitors = new Map<string, BatchProgressMonitor>();
  private progressCallbacks = new Map<string, ProgressCallback[]>();
  
  startMonitoring(jobId: string, totalFiles: number): void {
    const monitor: BatchProgressMonitor = {
      jobId,
      totalFiles,
      processedFiles: 0,
      estimatedTimeRemaining: 0,
      processingSpeed: 0,
      startTime: new Date()
    };
    
    this.monitors.set(jobId, monitor);
  }
  
  updateProgress(jobId: string, processedFiles: number, currentFile?: string): void {
    const monitor = this.monitors.get(jobId);
    if (!monitor) return;
    
    monitor.processedFiles = processedFiles;
    monitor.currentFile = currentFile;
    
    // 计算处理速度
    const elapsedMinutes = (Date.now() - monitor.startTime.getTime()) / (1000 * 60);
    monitor.processingSpeed = processedFiles / Math.max(elapsedMinutes, 0.1);
    
    // 估算剩余时间
    const remainingFiles = monitor.totalFiles - processedFiles;
    monitor.estimatedTimeRemaining = remainingFiles / Math.max(monitor.processingSpeed, 0.1);
    
    // 通知进度更新
    this.notifyProgressUpdate(jobId, monitor);
  }
  
  private notifyProgressUpdate(jobId: string, monitor: BatchProgressMonitor): void {
    const callbacks = this.progressCallbacks.get(jobId) || [];
    callbacks.forEach(callback => {
      callback({
        percentage: (monitor.processedFiles / monitor.totalFiles) * 100,
        processedFiles: monitor.processedFiles,
        totalFiles: monitor.totalFiles,
        currentFile: monitor.currentFile,
        estimatedTimeRemaining: monitor.estimatedTimeRemaining,
        processingSpeed: monitor.processingSpeed
      });
    });
  }
  
  onProgress(jobId: string, callback: ProgressCallback): void {
    if (!this.progressCallbacks.has(jobId)) {
      this.progressCallbacks.set(jobId, []);
    }
    this.progressCallbacks.get(jobId)!.push(callback);
  }
}
```
[Source: architecture.md#components]

### 结果报告生成
```typescript
interface BatchReport {
  jobId: string;
  jobName: string;
  summary: ReportSummary;
  fileResults: FileReport[];
  performance: PerformanceMetrics;
  errors: ErrorSummary[];
  generatedAt: Date;
}

interface ReportSummary {
  totalFiles: number;
  successfulFiles: number;
  failedFiles: number;
  skippedFiles: number;
  totalProcessingTime: number;
  averageFileSize: number;
  totalSpaceSaved?: number;
}

class BatchReportGenerator {
  generateReport(job: BatchJob): BatchReport {
    const summary = this.calculateSummary(job);
    const fileResults = this.generateFileReports(job);
    const performance = this.calculatePerformanceMetrics(job);
    const errors = this.summarizeErrors(job);
    
    return {
      jobId: job.id,
      jobName: job.name,
      summary,
      fileResults,
      performance,
      errors,
      generatedAt: new Date()
    };
  }
  
  private calculateSummary(job: BatchJob): ReportSummary {
    const totalFiles = job.files.length;
    const successfulFiles = job.files.filter(f => f.status === FileProcessingStatus.COMPLETED).length;
    const failedFiles = job.files.filter(f => f.status === FileProcessingStatus.FAILED).length;
    const skippedFiles = job.files.filter(f => f.status === FileProcessingStatus.SKIPPED).length;
    
    const totalProcessingTime = job.completedAt && job.startedAt 
      ? job.completedAt.getTime() - job.startedAt.getTime()
      : 0;
    
    const averageFileSize = job.files.reduce((sum, f) => sum + f.fileSize, 0) / totalFiles;
    
    return {
      totalFiles,
      successfulFiles,
      failedFiles,
      skippedFiles,
      totalProcessingTime,
      averageFileSize
    };
  }
  
  exportReport(report: BatchReport, format: 'json' | 'csv' | 'html'): string {
    switch (format) {
      case 'json':
        return JSON.stringify(report, null, 2);
      case 'csv':
        return this.generateCSVReport(report);
      case 'html':
        return this.generateHTMLReport(report);
      default:
        throw new Error(`不支持的导出格式: ${format}`);
    }
  }
  
  private generateHTMLReport(report: BatchReport): string {
    return `
      <!DOCTYPE html>
      <html>
      <head>
        <title>批量处理报告 - ${report.jobName}</title>
        <style>
          body { font-family: Arial, sans-serif; margin: 20px; }
          .summary { background: #f5f5f5; padding: 15px; border-radius: 5px; }
          .metrics { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; }
          .metric { text-align: center; }
          .metric-value { font-size: 2em; font-weight: bold; color: #2196F3; }
          table { width: 100%; border-collapse: collapse; margin-top: 20px; }
          th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
          th { background-color: #f2f2f2; }
          .success { color: green; }
          .failed { color: red; }
          .skipped { color: orange; }
        </style>
      </head>
      <body>
        <h1>批量处理报告</h1>
        <div class="summary">
          <h2>${report.jobName}</h2>
          <p>生成时间: ${report.generatedAt.toLocaleString()}</p>
          <div class="metrics">
            <div class="metric">
              <div class="metric-value">${report.summary.totalFiles}</div>
              <div>总文件数</div>
            </div>
            <div class="metric">
              <div class="metric-value success">${report.summary.successfulFiles}</div>
              <div>成功处理</div>
            </div>
            <div class="metric">
              <div class="metric-value failed">${report.summary.failedFiles}</div>
              <div>处理失败</div>
            </div>
            <div class="metric">
              <div class="metric-value">${(report.summary.totalProcessingTime / 1000 / 60).toFixed(1)}分钟</div>
              <div>总处理时间</div>
            </div>
          </div>
        </div>
        
        <h3>文件处理详情</h3>
        <table>
          <thead>
            <tr>
              <th>文件名</th>
              <th>状态</th>
              <th>文件大小</th>
              <th>处理时间</th>
              <th>错误信息</th>
            </tr>
          </thead>
          <tbody>
            ${report.fileResults.map(file => `
              <tr>
                <td>${file.fileName}</td>
                <td class="${file.status}">${this.getStatusDisplayName(file.status)}</td>
                <td>${this.formatFileSize(file.fileSize)}</td>
                <td>${file.processingTime ? (file.processingTime / 1000).toFixed(1) + 's' : '-'}</td>
                <td>${file.error || '-'}</td>
              </tr>
            `).join('')}
          </tbody>
        </table>
      </body>
      </html>
    `;
  }
}
```
[Source: architecture.md#components]

### 性能优化
- **并行处理**: 支持多文件并行处理，提高整体效率
- **内存管理**: 大批量文件分批加载，避免内存溢出
- **断点续传**: 支持任务暂停和恢复，处理中断后可继续
- **智能调度**: 根据系统资源动态调整并发数量
[Source: architecture.md#performance-optimization]

### Testing
**测试文件位置**: `tests/renderer/services/BatchProcessingEngine.test.ts`
**测试框架**: Jest + File System Mock
**关键测试场景**:
- 大批量文件处理稳定性测试
- 工作流执行正确性验证测试
- 错误处理和恢复机制测试
- 进度监控准确性测试
- 报告生成完整性测试
**测试标准**:
- 批量处理成功率≥95%
- 工作流执行准确率100%
- 错误恢复成功率≥90%
- 进度监控精度≥95%
- 内存使用稳定
[Source: architecture.md#testing-strategy]

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-21 | v1.0 | 初始故事创建 | Bob (SM) |

## Dev Agent Record
*此部分将在开发实施过程中由开发代理填充*

### Agent Model Used
*待填充*

### Debug Log References
*待填充*

### Completion Notes List
*待填充*

### File List
*待填充*

## QA Results
*此部分将在QA代理审查完成后填充*
