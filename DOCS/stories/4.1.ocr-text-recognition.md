# Story 4.1: OCR文字识别功能

## Status
Draft

## Story
**As a** 用户,
**I want** 系统能够识别扫描PDF中的文字内容,
**so that** 我能够编辑和搜索原本无法选择的文字

## Acceptance Criteria
1. 集成OCR引擎识别图像中的文字
2. 支持中英文混合文字识别
3. 识别准确率达到90%以上
4. 将识别结果叠加到原始图像上
5. 支持手动校正识别错误
6. 处理时间控制在每页5秒以内

## Tasks / Subtasks
- [ ] 集成OCR引擎 (AC: 1, 6)
  - [ ] 选择和集成Tesseract.js OCR引擎
  - [ ] 配置OCR引擎参数和模型
  - [ ] 实现图像预处理优化识别效果
  - [ ] 优化OCR处理性能
- [ ] 实现多语言支持 (AC: 2, 3)
  - [ ] 配置中文简体识别模型
  - [ ] 支持英文识别
  - [ ] 实现中英文混合识别
  - [ ] 优化识别准确率
- [ ] 开发文字叠加功能 (AC: 4)
  - [ ] 创建透明文字层
  - [ ] 实现文字位置精确对齐
  - [ ] 保持原始图像显示效果
  - [ ] 支持文字选择和复制
- [ ] 实现手动校正功能 (AC: 5)
  - [ ] 创建文字校正界面
  - [ ] 支持逐字编辑和修正
  - [ ] 实现校正结果保存
  - [ ] 添加校正历史记录

## Dev Notes

### OCR集成架构
```typescript
interface OCRResult {
  text: string;
  confidence: number;
  boundingBox: BoundingBox;
  words: OCRWord[];
  lines: OCRLine[];
  paragraphs: OCRParagraph[];
}

interface OCRWord {
  text: string;
  confidence: number;
  boundingBox: BoundingBox;
  fontSize: number;
  fontFamily?: string;
}

interface BoundingBox {
  x: number;
  y: number;
  width: number;
  height: number;
}

class OCREngine {
  private tesseract: Tesseract.Worker;
  private isInitialized = false;
  
  async initialize(): Promise<void> {
    if (this.isInitialized) return;
    
    this.tesseract = await Tesseract.createWorker({
      logger: m => this.handleProgress(m)
    });
    
    // 加载中英文语言包
    await this.tesseract.loadLanguage('chi_sim+eng');
    await this.tesseract.initialize('chi_sim+eng');
    
    // 配置OCR参数
    await this.tesseract.setParameters({
      tessedit_pageseg_mode: Tesseract.PSM.SPARSE_TEXT,
      tessedit_char_whitelist: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz一二三四五六七八九十',
      preserve_interword_spaces: '1'
    });
    
    this.isInitialized = true;
  }
  
  async recognizeText(imageData: ImageData, pageNumber: number): Promise<OCRResult> {
    if (!this.isInitialized) {
      await this.initialize();
    }
    
    // 图像预处理
    const processedImage = await this.preprocessImage(imageData);
    
    // 执行OCR识别
    const result = await this.tesseract.recognize(processedImage);
    
    // 处理识别结果
    return this.processOCRResult(result, pageNumber);
  }
}
```
[Source: architecture.md#tech-stack]

### 图像预处理优化
```typescript
class ImagePreprocessor {
  preprocessImage(imageData: ImageData): Promise<ImageData> {
    return new Promise((resolve) => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d')!;
      
      canvas.width = imageData.width;
      canvas.height = imageData.height;
      ctx.putImageData(imageData, 0, 0);
      
      // 应用预处理滤镜
      this.applyGrayscale(ctx, canvas.width, canvas.height);
      this.applyContrast(ctx, canvas.width, canvas.height, 1.2);
      this.applySharpening(ctx, canvas.width, canvas.height);
      this.applyNoiseReduction(ctx, canvas.width, canvas.height);
      
      const processedImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      resolve(processedImageData);
    });
  }
  
  private applyGrayscale(ctx: CanvasRenderingContext2D, width: number, height: number): void {
    const imageData = ctx.getImageData(0, 0, width, height);
    const data = imageData.data;
    
    for (let i = 0; i < data.length; i += 4) {
      const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
      data[i] = gray;     // Red
      data[i + 1] = gray; // Green
      data[i + 2] = gray; // Blue
    }
    
    ctx.putImageData(imageData, 0, 0);
  }
  
  private applyContrast(ctx: CanvasRenderingContext2D, width: number, height: number, factor: number): void {
    const imageData = ctx.getImageData(0, 0, width, height);
    const data = imageData.data;
    
    for (let i = 0; i < data.length; i += 4) {
      data[i] = Math.min(255, Math.max(0, (data[i] - 128) * factor + 128));
      data[i + 1] = Math.min(255, Math.max(0, (data[i + 1] - 128) * factor + 128));
      data[i + 2] = Math.min(255, Math.max(0, (data[i + 2] - 128) * factor + 128));
    }
    
    ctx.putImageData(imageData, 0, 0);
  }
  
  private applySharpening(ctx: CanvasRenderingContext2D, width: number, height: number): void {
    const imageData = ctx.getImageData(0, 0, width, height);
    const data = imageData.data;
    const output = new Uint8ClampedArray(data);
    
    // 锐化卷积核
    const kernel = [
      0, -1, 0,
      -1, 5, -1,
      0, -1, 0
    ];
    
    for (let y = 1; y < height - 1; y++) {
      for (let x = 1; x < width - 1; x++) {
        for (let c = 0; c < 3; c++) {
          let sum = 0;
          for (let ky = -1; ky <= 1; ky++) {
            for (let kx = -1; kx <= 1; kx++) {
              const idx = ((y + ky) * width + (x + kx)) * 4 + c;
              sum += data[idx] * kernel[(ky + 1) * 3 + (kx + 1)];
            }
          }
          output[(y * width + x) * 4 + c] = Math.min(255, Math.max(0, sum));
        }
      }
    }
    
    ctx.putImageData(new ImageData(output, width, height), 0, 0);
  }
}
```
[Source: architecture.md#components]

### 文字叠加系统
```typescript
class TextOverlayManager {
  private overlayCanvas: HTMLCanvasElement;
  private textLayers = new Map<number, TextLayer>();
  
  createTextOverlay(pageNumber: number, ocrResult: OCRResult): TextLayer {
    const textLayer: TextLayer = {
      pageNumber,
      textBlocks: this.convertOCRToTextBlocks(ocrResult),
      isVisible: true,
      isEditable: false
    };
    
    this.textLayers.set(pageNumber, textLayer);
    this.renderTextLayer(textLayer);
    
    return textLayer;
  }
  
  private convertOCRToTextBlocks(ocrResult: OCRResult): TextBlock[] {
    return ocrResult.words.map(word => ({
      id: this.generateBlockId(),
      text: word.text,
      x: word.boundingBox.x,
      y: word.boundingBox.y,
      width: word.boundingBox.width,
      height: word.boundingBox.height,
      fontSize: word.fontSize,
      fontFamily: word.fontFamily || 'Arial',
      color: 'transparent', // 透明文字，仅用于选择
      backgroundColor: 'transparent',
      confidence: word.confidence,
      isOCRGenerated: true
    }));
  }
  
  private renderTextLayer(textLayer: TextLayer): void {
    const canvas = this.getOrCreateCanvas(textLayer.pageNumber);
    const ctx = canvas.getContext('2d')!;
    
    // 清除之前的内容
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 渲染文字块
    textLayer.textBlocks.forEach(block => {
      this.renderTextBlock(ctx, block);
    });
  }
  
  private renderTextBlock(ctx: CanvasRenderingContext2D, block: TextBlock): void {
    // 设置透明文字样式
    ctx.font = `${block.fontSize}px ${block.fontFamily}`;
    ctx.fillStyle = 'rgba(0, 0, 0, 0.01)'; // 几乎透明，但可选择
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    
    // 绘制文字
    ctx.fillText(block.text, block.x, block.y);
    
    // 如果是调试模式，显示边界框
    if (this.debugMode) {
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 1;
      ctx.strokeRect(block.x, block.y, block.width, block.height);
    }
  }
  
  enableTextSelection(pageNumber: number): void {
    const textLayer = this.textLayers.get(pageNumber);
    if (!textLayer) return;
    
    // 添加文字选择事件监听
    const canvas = this.getCanvas(pageNumber);
    canvas.addEventListener('mousedown', this.handleTextSelection.bind(this));
    canvas.addEventListener('mousemove', this.handleTextSelection.bind(this));
    canvas.addEventListener('mouseup', this.handleTextSelection.bind(this));
  }
  
  private handleTextSelection(event: MouseEvent): void {
    const canvas = event.target as HTMLCanvasElement;
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    
    // 查找点击位置的文字块
    const pageNumber = this.getPageNumberFromCanvas(canvas);
    const textLayer = this.textLayers.get(pageNumber);
    
    if (textLayer) {
      const hitBlock = this.findTextBlockAt(textLayer, x, y);
      if (hitBlock) {
        this.selectTextBlock(hitBlock);
      }
    }
  }
}
```
[Source: architecture.md#components]

### 手动校正功能
```typescript
interface CorrectionSession {
  pageNumber: number;
  originalOCR: OCRResult;
  corrections: TextCorrection[];
  isActive: boolean;
}

interface TextCorrection {
  blockId: string;
  originalText: string;
  correctedText: string;
  confidence: number;
  timestamp: Date;
}

class OCRCorrectionManager {
  private activeSessions = new Map<number, CorrectionSession>();
  
  startCorrectionSession(pageNumber: number, ocrResult: OCRResult): string {
    const sessionId = this.generateSessionId();
    
    const session: CorrectionSession = {
      pageNumber,
      originalOCR: ocrResult,
      corrections: [],
      isActive: true
    };
    
    this.activeSessions.set(pageNumber, session);
    return sessionId;
  }
  
  correctText(pageNumber: number, blockId: string, correctedText: string): void {
    const session = this.activeSessions.get(pageNumber);
    if (!session || !session.isActive) return;
    
    // 查找原始文字块
    const originalBlock = session.originalOCR.words.find(w => w.id === blockId);
    if (!originalBlock) return;
    
    // 创建校正记录
    const correction: TextCorrection = {
      blockId,
      originalText: originalBlock.text,
      correctedText,
      confidence: this.calculateCorrectionConfidence(originalBlock.text, correctedText),
      timestamp: new Date()
    };
    
    // 更新或添加校正
    const existingIndex = session.corrections.findIndex(c => c.blockId === blockId);
    if (existingIndex >= 0) {
      session.corrections[existingIndex] = correction;
    } else {
      session.corrections.push(correction);
    }
    
    // 更新文字叠加层
    this.updateTextOverlay(pageNumber, blockId, correctedText);
  }
  
  private calculateCorrectionConfidence(original: string, corrected: string): number {
    // 基于编辑距离计算校正置信度
    const editDistance = this.calculateEditDistance(original, corrected);
    const maxLength = Math.max(original.length, corrected.length);
    
    if (maxLength === 0) return 1;
    
    return Math.max(0, 1 - editDistance / maxLength);
  }
  
  private calculateEditDistance(str1: string, str2: string): number {
    const matrix = Array(str2.length + 1).fill(null).map(() => Array(str1.length + 1).fill(null));
    
    for (let i = 0; i <= str1.length; i++) matrix[0][i] = i;
    for (let j = 0; j <= str2.length; j++) matrix[j][0] = j;
    
    for (let j = 1; j <= str2.length; j++) {
      for (let i = 1; i <= str1.length; i++) {
        const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1;
        matrix[j][i] = Math.min(
          matrix[j][i - 1] + 1,     // deletion
          matrix[j - 1][i] + 1,     // insertion
          matrix[j - 1][i - 1] + indicator // substitution
        );
      }
    }
    
    return matrix[str2.length][str1.length];
  }
  
  applyCorrectionBatch(pageNumber: number, corrections: TextCorrection[]): void {
    const session = this.activeSessions.get(pageNumber);
    if (!session) return;
    
    corrections.forEach(correction => {
      this.correctText(pageNumber, correction.blockId, correction.correctedText);
    });
    
    // 保存校正结果
    this.saveCorrectionSession(session);
  }
  
  private saveCorrectionSession(session: CorrectionSession): void {
    // 将校正结果保存到文档分析中
    const updatedAnalysis = this.applyCorrectionsToAnalysis(session);
    this.analysisService.updateAnalysis(session.pageNumber, updatedAnalysis);
    
    // 保存校正历史
    this.correctionHistory.addSession(session);
  }
}
```
[Source: architecture.md#components]

### 校正界面组件
```typescript
interface OCRCorrectionProps {
  pageNumber: number;
  ocrResult: OCRResult;
  onCorrectionComplete: (corrections: TextCorrection[]) => void;
}

class OCRCorrectionInterface extends React.Component<OCRCorrectionProps> {
  private correctionManager = new OCRCorrectionManager();
  
  state = {
    selectedBlock: null as OCRWord | null,
    correctionText: '',
    corrections: [] as TextCorrection[],
    showConfidenceFilter: false,
    confidenceThreshold: 0.8
  };
  
  componentDidMount() {
    this.correctionManager.startCorrectionSession(
      this.props.pageNumber, 
      this.props.ocrResult
    );
  }
  
  render() {
    const { ocrResult } = this.props;
    const lowConfidenceWords = ocrResult.words.filter(
      word => word.confidence < this.state.confidenceThreshold
    );
    
    return (
      <div className="ocr-correction-interface">
        <div className="correction-header">
          <h3>OCR文字校正 - 第{this.props.pageNumber}页</h3>
          <div className="confidence-filter">
            <label>
              <input
                type="checkbox"
                checked={this.state.showConfidenceFilter}
                onChange={this.toggleConfidenceFilter}
              />
              只显示低置信度文字
            </label>
            <input
              type="range"
              min="0"
              max="1"
              step="0.1"
              value={this.state.confidenceThreshold}
              onChange={this.handleThresholdChange}
            />
            <span>{(this.state.confidenceThreshold * 100).toFixed(0)}%</span>
          </div>
        </div>
        
        <div className="correction-content">
          <div className="word-list">
            {(this.state.showConfidenceFilter ? lowConfidenceWords : ocrResult.words)
              .map(word => (
                <WordCorrectionItem
                  key={word.id}
                  word={word}
                  isSelected={this.state.selectedBlock?.id === word.id}
                  correction={this.findCorrection(word.id)}
                  onSelect={() => this.selectWord(word)}
                  onCorrect={(correctedText) => this.correctWord(word.id, correctedText)}
                />
              ))}
          </div>
          
          <div className="correction-panel">
            {this.state.selectedBlock && (
              <WordCorrectionPanel
                word={this.state.selectedBlock}
                onCorrect={this.handleWordCorrection}
                onSkip={this.skipWord}
              />
            )}
          </div>
        </div>
        
        <div className="correction-actions">
          <button onClick={this.applyAllCorrections}>
            应用所有校正 ({this.state.corrections.length})
          </button>
          <button onClick={this.resetCorrections}>
            重置校正
          </button>
          <button onClick={this.autoCorrectLowConfidence}>
            自动校正低置信度文字
          </button>
        </div>
      </div>
    );
  }
  
  private selectWord = (word: OCRWord): void => {
    this.setState({ selectedBlock: word });
  };
  
  private correctWord = (wordId: string, correctedText: string): void => {
    this.correctionManager.correctText(this.props.pageNumber, wordId, correctedText);
    
    // 更新本地状态
    const correction = {
      blockId: wordId,
      originalText: this.state.selectedBlock?.text || '',
      correctedText,
      confidence: 1.0,
      timestamp: new Date()
    };
    
    this.setState(prevState => ({
      corrections: [...prevState.corrections.filter(c => c.blockId !== wordId), correction]
    }));
  };
  
  private applyAllCorrections = (): void => {
    this.correctionManager.applyCorrectionBatch(
      this.props.pageNumber, 
      this.state.corrections
    );
    this.props.onCorrectionComplete(this.state.corrections);
  };
}
```
[Source: architecture.md#components]

### 性能优化
- **Web Worker**: 在后台线程执行OCR处理
- **分页处理**: 按页面分批处理，避免内存溢出
- **缓存机制**: 缓存OCR结果和校正记录
- **增量更新**: 只重新处理修改的区域
[Source: architecture.md#performance-optimization]

### Testing
**测试文件位置**: `tests/renderer/services/OCREngine.test.ts`
**测试框架**: Jest + Tesseract.js Mock
**关键测试场景**:
- 中英文混合文字识别准确性测试
- 图像预处理效果验证测试
- 文字叠加位置精度测试
- 手动校正功能完整性测试
- OCR处理性能基准测试
**测试标准**:
- 识别准确率≥90%
- 处理时间≤5秒/页
- 文字定位精度≥95%
- 校正功能可用性100%
- 内存使用稳定
[Source: architecture.md#testing-strategy]

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-21 | v1.0 | 初始故事创建 | Bob (SM) |

## Dev Agent Record
*此部分将在开发实施过程中由开发代理填充*

### Agent Model Used
*待填充*

### Debug Log References
*待填充*

### Completion Notes List
*待填充*

### File List
*待填充*

## QA Results
*此部分将在QA代理审查完成后填充*