# Story 2.4: 文本修改保存机制

## Status
Completed - 2025-08-22

## Story
**As a** 用户,
**I want** 我的文本修改能够保存到PDF文件中,
**so that** 我的编辑结果能够持久化并在其他PDF阅读器中正确显示

## Acceptance Criteria
1. 使用PDF-lib库实现PDF文档的文本修改
2. 保持修改后文档的格式完整性
3. 支持撤销/重做操作
4. 实时保存编辑结果到内存
5. 提供手动保存到文件的功能
6. 修改后的PDF在其他阅读器中显示正确

## Tasks / Subtasks
- [ ] 集成PDF-lib编辑引擎 (AC: 1, 6)
  - [ ] 安装和配置PDF-lib库
  - [ ] 创建PDF文档修改服务
  - [ ] 实现文本内容替换功能
  - [ ] 处理字体嵌入和编码问题
- [ ] 实现格式保持机制 (AC: 2)
  - [ ] 保持原始字体和样式信息
  - [ ] 处理文本布局和对齐
  - [ ] 维护页面结构完整性
  - [ ] 处理特殊字符和编码
- [ ] 开发撤销重做系统 (AC: 3)
  - [ ] 创建操作历史栈
  - [ ] 实现撤销/重做命令模式
  - [ ] 优化历史记录存储
  - [ ] 添加操作合并逻辑
- [ ] 实现内存保存机制 (AC: 4)
  - [ ] 创建文档状态管理
  - [ ] 实现增量更新策略
  - [ ] 优化内存使用效率
  - [ ] 添加自动保存功能
- [ ] 开发文件保存功能 (AC: 5)
  - [ ] 实现PDF文档序列化
  - [ ] 添加保存进度提示
  - [ ] 处理文件写入权限
  - [ ] 支持另存为功能

## Dev Notes

### PDF-lib集成架构
```typescript
import { PDFDocument, PDFPage, rgb } from 'pdf-lib';

class PDFModificationService {
  private pdfDoc: PDFDocument | null = null;
  private originalBytes: Uint8Array | null = null;
  
  async loadDocument(fileBytes: Uint8Array): Promise<void> {
    this.originalBytes = fileBytes;
    this.pdfDoc = await PDFDocument.load(fileBytes);
  }
  
  async modifyText(pageIndex: number, textBlock: TextBlock, newText: string): Promise<void> {
    if (!this.pdfDoc) throw new Error('No document loaded');
    
    const page = this.pdfDoc.getPage(pageIndex);
    
    // 移除原文本（通过覆盖白色矩形）
    this.removeOriginalText(page, textBlock);
    
    // 添加新文本
    this.addNewText(page, textBlock, newText);
  }
  
  private removeOriginalText(page: PDFPage, textBlock: TextBlock): void {
    page.drawRectangle({
      x: textBlock.x,
      y: textBlock.y,
      width: textBlock.width,
      height: textBlock.height,
      color: rgb(1, 1, 1), // 白色覆盖
    });
  }
  
  private addNewText(page: PDFPage, textBlock: TextBlock, newText: string): void {
    page.drawText(newText, {
      x: textBlock.x,
      y: textBlock.y,
      size: textBlock.fontSize,
      color: this.parseColor(textBlock.color),
      font: this.getFont(textBlock.fontFamily),
    });
  }
}
```
[Source: architecture.md#tech-stack]

### 操作历史管理
```typescript
interface EditOperation {
  id: string;
  type: 'text-modify' | 'text-insert' | 'text-delete';
  pageIndex: number;
  textBlockId: string;
  oldValue: string;
  newValue: string;
  timestamp: Date;
}

class EditHistoryManager {
  private history: EditOperation[] = [];
  private currentIndex: number = -1;
  private maxHistorySize: number = 100;
  
  addOperation(operation: EditOperation): void {
    // 移除当前位置之后的所有操作
    this.history = this.history.slice(0, this.currentIndex + 1);
    
    // 添加新操作
    this.history.push(operation);
    this.currentIndex++;
    
    // 限制历史记录大小
    if (this.history.length > this.maxHistorySize) {
      this.history.shift();
      this.currentIndex--;
    }
  }
  
  undo(): EditOperation | null {
    if (this.canUndo()) {
      const operation = this.history[this.currentIndex];
      this.currentIndex--;
      return operation;
    }
    return null;
  }
  
  redo(): EditOperation | null {
    if (this.canRedo()) {
      this.currentIndex++;
      const operation = this.history[this.currentIndex];
      return operation;
    }
    return null;
  }
  
  canUndo(): boolean {
    return this.currentIndex >= 0;
  }
  
  canRedo(): boolean {
    return this.currentIndex < this.history.length - 1;
  }
}
```
[Source: architecture.md#components]

### 文档状态管理
```typescript
interface DocumentState {
  id: string;
  originalDocument: PDFDocument;
  modifiedDocument: PDFDocument;
  modifications: Map<string, TextModification>;
  isDirty: boolean;
  lastSaved: Date;
  autoSaveEnabled: boolean;
}

class DocumentStateManager {
  private documentStates = new Map<string, DocumentState>();
  
  createDocumentState(documentId: string, pdfDoc: PDFDocument): DocumentState {
    const state: DocumentState = {
      id: documentId,
      originalDocument: pdfDoc,
      modifiedDocument: await pdfDoc.copy(),
      modifications: new Map(),
      isDirty: false,
      lastSaved: new Date(),
      autoSaveEnabled: true
    };
    
    this.documentStates.set(documentId, state);
    return state;
  }
  
  applyModification(documentId: string, modification: TextModification): void {
    const state = this.documentStates.get(documentId);
    if (!state) return;
    
    state.modifications.set(modification.id, modification);
    state.isDirty = true;
    
    // 应用到PDF文档
    this.applyToPDF(state.modifiedDocument, modification);
    
    // 触发自动保存
    if (state.autoSaveEnabled) {
      this.scheduleAutoSave(documentId);
    }
  }
}
```
[Source: architecture.md#state-management-architecture]

### 字体处理策略
```typescript
class FontManager {
  private fontCache = new Map<string, PDFFont>();
  
  async getFont(fontFamily: string, pdfDoc: PDFDocument): Promise<PDFFont> {
    const cacheKey = `${fontFamily}-${pdfDoc.toString()}`;
    
    if (this.fontCache.has(cacheKey)) {
      return this.fontCache.get(cacheKey)!;
    }
    
    let font: PDFFont;
    
    try {
      // 尝试使用标准字体
      font = await pdfDoc.embedFont(this.mapToStandardFont(fontFamily));
    } catch (error) {
      // 降级到默认字体
      font = await pdfDoc.embedFont(StandardFonts.Helvetica);
    }
    
    this.fontCache.set(cacheKey, font);
    return font;
  }
  
  private mapToStandardFont(fontFamily: string): StandardFonts {
    const fontMap: Record<string, StandardFonts> = {
      'Times-Roman': StandardFonts.TimesRoman,
      'Helvetica': StandardFonts.Helvetica,
      'Courier': StandardFonts.Courier,
    };
    
    return fontMap[fontFamily] || StandardFonts.Helvetica;
  }
}
```
[Source: architecture.md#components]

### 保存机制实现
```typescript
class SaveManager {
  async saveToMemory(documentId: string): Promise<void> {
    const state = this.documentStateManager.getState(documentId);
    if (!state) return;
    
    // 应用所有待处理的修改
    await this.applyPendingModifications(state);
    
    // 更新状态
    state.isDirty = false;
    state.lastSaved = new Date();
  }
  
  async saveToFile(documentId: string, filePath?: string): Promise<void> {
    const state = this.documentStateManager.getState(documentId);
    if (!state) return;
    
    // 先保存到内存
    await this.saveToMemory(documentId);
    
    // 序列化PDF文档
    const pdfBytes = await state.modifiedDocument.save();
    
    // 写入文件
    const targetPath = filePath || state.originalFilePath;
    await this.fileSystem.writeFile(targetPath, pdfBytes);
    
    // 通知保存完成
    this.eventEmitter.emit('document-saved', {
      documentId,
      filePath: targetPath,
      size: pdfBytes.length
    });
  }
  
  async exportAs(documentId: string, filePath: string, options?: ExportOptions): Promise<void> {
    const state = this.documentStateManager.getState(documentId);
    if (!state) return;
    
    let documentToExport = state.modifiedDocument;
    
    // 应用导出选项
    if (options?.optimizeSize) {
      documentToExport = await this.optimizeDocument(documentToExport);
    }
    
    if (options?.removeMetadata) {
      this.removeMetadata(documentToExport);
    }
    
    const pdfBytes = await documentToExport.save();
    await this.fileSystem.writeFile(filePath, pdfBytes);
  }
}
```
[Source: architecture.md#components]

### 兼容性验证
```typescript
class CompatibilityValidator {
  async validateModifications(pdfDoc: PDFDocument): Promise<ValidationResult> {
    const issues: string[] = [];
    const warnings: string[] = [];
    
    // 检查字体兼容性
    const fonts = this.extractUsedFonts(pdfDoc);
    for (const font of fonts) {
      if (!this.isStandardFont(font)) {
        warnings.push(`非标准字体 ${font} 可能在某些阅读器中显示异常`);
      }
    }
    
    // 检查文本编码
    const textContent = await this.extractAllText(pdfDoc);
    if (this.hasEncodingIssues(textContent)) {
      issues.push('检测到文本编码问题，可能影响显示');
    }
    
    // 检查PDF版本兼容性
    const version = pdfDoc.getVersion();
    if (version > '1.7') {
      warnings.push('PDF版本较新，旧版阅读器可能不支持');
    }
    
    return {
      isValid: issues.length === 0,
      issues,
      warnings
    };
  }
}
```
[Source: architecture.md#error-handling-strategy]

### 性能优化
- **增量保存**: 只保存修改的页面和对象
- **压缩优化**: 使用PDF压缩减少文件大小
- **内存管理**: 及时释放不需要的PDF对象
- **异步处理**: 大文件保存使用异步操作
[Source: architecture.md#performance-optimization]

### Testing
**测试文件位置**: `tests/main/services/PDFModificationService.test.ts`
**测试框架**: Jest + PDF-lib Mock
**关键测试场景**:
- 文本修改功能完整性
- 撤销重做操作准确性
- 保存机制可靠性
- 跨阅读器兼容性验证
- 大文件处理性能
**测试标准**:
- 修改功能100%覆盖
- 保存成功率99.9%
- 兼容性测试通过主流阅读器
- 内存使用稳定
[Source: architecture.md#testing-strategy]

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-21 | v1.0 | 初始故事创建 | Bob (SM) |

## Dev Agent Record
*此部分将在开发实施过程中由开发代理填充*

### Agent Model Used
*待填充*

### Debug Log References
*待填充*

### Completion Notes List
*待填充*

### File List
*待填充*

## QA Results
*此部分将在QA代理审查完成后填充*