# Story 3.2: 智能重命名建议功能

## Status
Draft

## Story
**As a** 用户,
**I want** 系统能够基于PDF内容自动生成有意义的文件名建议,
**so that** 我能够快速整理混乱命名的PDF文件

## Acceptance Criteria
1. 基于文档内容生成3-5个命名建议
2. 命名格式符合中文用户习惯（日期-类型-主题）
3. 避免特殊字符和过长文件名
4. 支持批量重命名操作
5. 提供命名规则自定义选项
6. 重命名建议准确率达到80%以上

## Tasks / Subtasks
- [ ] 实现命名建议算法 (AC: 1, 6)
  - [ ] 基于文档分析结果生成建议
  - [ ] 实现多种命名策略
  - [ ] 优化建议质量和相关性
  - [ ] 添加建议去重和排序
- [ ] 开发命名格式系统 (AC: 2, 3)
  - [ ] 定义中文用户友好的命名模板
  - [ ] 实现日期格式标准化
  - [ ] 处理特殊字符过滤和替换
  - [ ] 控制文件名长度限制
- [ ] 创建批量重命名功能 (AC: 4)
  - [ ] 实现多文件选择和预览
  - [ ] 开发批量应用命名建议
  - [ ] 添加重命名冲突检测
  - [ ] 实现批量操作撤销功能
- [ ] 实现自定义命名规则 (AC: 5)
  - [ ] 创建命名规则配置界面
  - [ ] 支持用户自定义模板
  - [ ] 实现规则保存和重用
  - [ ] 添加规则验证和预览

## Dev Notes

### 命名建议生成架构
```typescript
interface NamingSuggestion {
  id: string;
  suggestedName: string;
  confidence: number;
  strategy: NamingStrategy;
  components: NameComponents;
  reasoning: string;
}

interface NameComponents {
  date?: string;
  category?: string;
  title?: string;
  keywords?: string[];
  version?: string;
  extension: string;
}

enum NamingStrategy {
  DATE_CATEGORY_TITLE = 'date-category-title',
  CATEGORY_TITLE_DATE = 'category-title-date',
  TITLE_ONLY = 'title-only',
  KEYWORDS_BASED = 'keywords-based',
  CUSTOM_TEMPLATE = 'custom-template'
}

class SmartRenameEngine {
  async generateSuggestions(
    documentAnalysis: DocumentAnalysis,
    originalFileName: string
  ): Promise<NamingSuggestion[]> {
    const suggestions: NamingSuggestion[] = [];
    
    // 策略1: 日期-类型-标题
    suggestions.push(await this.generateDateCategoryTitle(documentAnalysis));
    
    // 策略2: 类型-标题-日期
    suggestions.push(await this.generateCategoryTitleDate(documentAnalysis));
    
    // 策略3: 仅标题
    suggestions.push(await this.generateTitleOnly(documentAnalysis));
    
    // 策略4: 关键词组合
    suggestions.push(await this.generateKeywordsBased(documentAnalysis));
    
    // 策略5: 智能优化原文件名
    suggestions.push(await this.optimizeOriginalName(originalFileName, documentAnalysis));
    
    // 排序和去重
    return this.rankAndDeduplicateSuggestions(suggestions);
  }
}
```
[Source: architecture.md#components]

### 中文命名模板系统
```typescript
class ChineseNamingTemplates {
  private templates: Map<NamingStrategy, NameTemplate> = new Map([
    [NamingStrategy.DATE_CATEGORY_TITLE, {
      pattern: '{date}-{category}-{title}',
      description: '日期-类型-标题格式',
      example: '2024-01-15-合同-租赁协议'
    }],
    [NamingStrategy.CATEGORY_TITLE_DATE, {
      pattern: '{category}-{title}-{date}',
      description: '类型-标题-日期格式',
      example: '发票-办公用品采购-2024-01-15'
    }],
    [NamingStrategy.TITLE_ONLY, {
      pattern: '{title}',
      description: '仅标题格式',
      example: '年度财务报告'
    }]
  ]);
  
  generateName(template: NameTemplate, components: NameComponents): string {
    let name = template.pattern;
    
    // 替换日期
    if (components.date) {
      name = name.replace('{date}', this.formatDate(components.date));
    }
    
    // 替换类别
    if (components.category) {
      name = name.replace('{category}', this.translateCategory(components.category));
    }
    
    // 替换标题
    if (components.title) {
      name = name.replace('{title}', this.cleanTitle(components.title));
    }
    
    // 添加扩展名
    return this.sanitizeFileName(name) + components.extension;
  }
  
  private translateCategory(category: string): string {
    const categoryMap: Record<string, string> = {
      'contract': '合同',
      'invoice': '发票',
      'report': '报告',
      'resume': '简历',
      'manual': '手册',
      'presentation': '演示',
      'academic': '学术',
      'legal': '法律',
      'financial': '财务'
    };
    
    return categoryMap[category] || '文档';
  }
  
  private formatDate(dateStr: string): string {
    const date = new Date(dateStr);
    return date.toISOString().split('T')[0]; // YYYY-MM-DD格式
  }
  
  private cleanTitle(title: string): string {
    return title
      .replace(/[^\u4e00-\u9fa5a-zA-Z0-9\s]/g, '') // 移除特殊字符
      .replace(/\s+/g, '-')                         // 空格替换为连字符
      .substring(0, 30)                             // 限制长度
      .trim();
  }
}
```
[Source: architecture.md#components]

### 文件名安全处理
```typescript
class FileNameSanitizer {
  private readonly INVALID_CHARS = /[<>:"/\\|?*\x00-\x1f]/g;
  private readonly RESERVED_NAMES = new Set([
    'CON', 'PRN', 'AUX', 'NUL',
    'COM1', 'COM2', 'COM3', 'COM4', 'COM5', 'COM6', 'COM7', 'COM8', 'COM9',
    'LPT1', 'LPT2', 'LPT3', 'LPT4', 'LPT5', 'LPT6', 'LPT7', 'LPT8', 'LPT9'
  ]);
  
  sanitizeFileName(fileName: string): string {
    // 移除无效字符
    let sanitized = fileName.replace(this.INVALID_CHARS, '');
    
    // 移除首尾空格和点
    sanitized = sanitized.replace(/^[\s.]+|[\s.]+$/g, '');
    
    // 检查保留名称
    const nameWithoutExt = sanitized.split('.')[0].toUpperCase();
    if (this.RESERVED_NAMES.has(nameWithoutExt)) {
      sanitized = `文档_${sanitized}`;
    }
    
    // 限制长度（Windows文件名限制255字符）
    if (sanitized.length > 200) {
      const ext = this.getFileExtension(sanitized);
      const nameOnly = sanitized.substring(0, 200 - ext.length);
      sanitized = nameOnly + ext;
    }
    
    // 确保不为空
    if (!sanitized || sanitized === '.pdf') {
      sanitized = `未命名文档_${Date.now()}.pdf`;
    }
    
    return sanitized;
  }
  
  validateFileName(fileName: string): ValidationResult {
    const issues: string[] = [];
    
    if (this.INVALID_CHARS.test(fileName)) {
      issues.push('文件名包含无效字符');
    }
    
    if (fileName.length > 255) {
      issues.push('文件名过长');
    }
    
    const nameWithoutExt = fileName.split('.')[0].toUpperCase();
    if (this.RESERVED_NAMES.has(nameWithoutExt)) {
      issues.push('文件名与系统保留名称冲突');
    }
    
    return {
      isValid: issues.length === 0,
      issues,
      warnings: []
    };
  }
}
```
[Source: architecture.md#components]

### 批量重命名管理
```typescript
interface BatchRenameOperation {
  id: string;
  files: FileRenameItem[];
  strategy: NamingStrategy;
  customTemplate?: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  progress: number;
  conflicts: RenameConflict[];
}

interface FileRenameItem {
  documentId: string;
  originalName: string;
  suggestedName: string;
  finalName: string;
  status: 'pending' | 'renamed' | 'skipped' | 'failed';
  error?: string;
}

class BatchRenameManager {
  private operations = new Map<string, BatchRenameOperation>();
  
  async createBatchOperation(
    documentIds: string[],
    strategy: NamingStrategy,
    customTemplate?: string
  ): Promise<string> {
    const operationId = this.generateOperationId();
    
    // 生成重命名项目
    const files: FileRenameItem[] = [];
    for (const documentId of documentIds) {
      const document = await this.documentService.getDocument(documentId);
      const analysis = await this.analysisService.getAnalysis(documentId);
      const suggestions = await this.renameEngine.generateSuggestions(analysis, document.fileName);
      
      const suggestion = suggestions.find(s => s.strategy === strategy) || suggestions[0];
      
      files.push({
        documentId,
        originalName: document.fileName,
        suggestedName: suggestion.suggestedName,
        finalName: suggestion.suggestedName,
        status: 'pending'
      });
    }
    
    // 检测冲突
    const conflicts = this.detectNamingConflicts(files);
    
    const operation: BatchRenameOperation = {
      id: operationId,
      files,
      strategy,
      customTemplate,
      status: 'pending',
      progress: 0,
      conflicts
    };
    
    this.operations.set(operationId, operation);
    return operationId;
  }
  
  async executeBatchRename(operationId: string): Promise<void> {
    const operation = this.operations.get(operationId);
    if (!operation) throw new Error('操作不存在');
    
    operation.status = 'processing';
    
    try {
      for (let i = 0; i < operation.files.length; i++) {
        const file = operation.files[i];
        
        try {
          await this.renameFile(file);
          file.status = 'renamed';
        } catch (error) {
          file.status = 'failed';
          file.error = error.message;
        }
        
        // 更新进度
        operation.progress = ((i + 1) / operation.files.length) * 100;
        this.notifyProgress(operationId, operation.progress);
      }
      
      operation.status = 'completed';
    } catch (error) {
      operation.status = 'failed';
      throw error;
    }
  }
  
  private detectNamingConflicts(files: FileRenameItem[]): RenameConflict[] {
    const conflicts: RenameConflict[] = [];
    const nameMap = new Map<string, FileRenameItem[]>();
    
    // 按建议名称分组
    files.forEach(file => {
      const name = file.suggestedName.toLowerCase();
      if (!nameMap.has(name)) {
        nameMap.set(name, []);
      }
      nameMap.get(name)!.push(file);
    });
    
    // 找出冲突
    nameMap.forEach((conflictFiles, name) => {
      if (conflictFiles.length > 1) {
        conflicts.push({
          suggestedName: name,
          conflictingFiles: conflictFiles,
          resolution: 'add-suffix'
        });
      }
    });
    
    return conflicts;
  }
}
```
[Source: architecture.md#components]

### 自定义命名规则
```typescript
interface CustomNamingRule {
  id: string;
  name: string;
  template: string;
  description: string;
  variables: TemplateVariable[];
  isActive: boolean;
  createdAt: Date;
}

interface TemplateVariable {
  name: string;
  type: 'text' | 'date' | 'category' | 'keywords' | 'counter';
  required: boolean;
  defaultValue?: string;
  format?: string;
}

class CustomNamingRuleManager {
  private rules = new Map<string, CustomNamingRule>();
  
  createRule(rule: Omit<CustomNamingRule, 'id' | 'createdAt'>): string {
    const ruleId = this.generateRuleId();
    const newRule: CustomNamingRule = {
      ...rule,
      id: ruleId,
      createdAt: new Date()
    };
    
    this.rules.set(ruleId, newRule);
    this.saveRules();
    return ruleId;
  }
  
  applyCustomRule(rule: CustomNamingRule, components: NameComponents): string {
    let result = rule.template;
    
    // 替换模板变量
    rule.variables.forEach(variable => {
      const placeholder = `{${variable.name}}`;
      let value = this.getVariableValue(variable, components);
      
      if (!value && variable.required) {
        value = variable.defaultValue || '未知';
      }
      
      if (value) {
        result = result.replace(new RegExp(placeholder, 'g'), value);
      }
    });
    
    return this.sanitizeFileName(result);
  }
  
  private getVariableValue(variable: TemplateVariable, components: NameComponents): string {
    switch (variable.type) {
      case 'date':
        return components.date ? this.formatDate(components.date, variable.format) : '';
      case 'category':
        return components.category || '';
      case 'text':
        return components.title || '';
      case 'keywords':
        return components.keywords?.slice(0, 3).join('-') || '';
      case 'counter':
        return this.getNextCounter().toString();
      default:
        return '';
    }
  }
}
```
[Source: architecture.md#components]

### 命名质量评估
```typescript
class NamingQualityAssessor {
  assessSuggestion(suggestion: NamingSuggestion, context: AssessmentContext): QualityScore {
    const scores = {
      relevance: this.assessRelevance(suggestion, context),
      readability: this.assessReadability(suggestion.suggestedName),
      uniqueness: this.assessUniqueness(suggestion.suggestedName, context),
      compliance: this.assessCompliance(suggestion.suggestedName)
    };
    
    const overallScore = (
      scores.relevance * 0.4 +
      scores.readability * 0.3 +
      scores.uniqueness * 0.2 +
      scores.compliance * 0.1
    );
    
    return {
      overall: overallScore,
      breakdown: scores,
      feedback: this.generateFeedback(scores)
    };
  }
  
  private assessRelevance(suggestion: NamingSuggestion, context: AssessmentContext): number {
    let score = 0;
    
    // 检查是否包含关键信息
    if (suggestion.components.category) score += 0.3;
    if (suggestion.components.title) score += 0.4;
    if (suggestion.components.date) score += 0.2;
    if (suggestion.components.keywords?.length > 0) score += 0.1;
    
    return Math.min(score, 1);
  }
  
  private assessReadability(fileName: string): number {
    let score = 1;
    
    // 长度检查
    if (fileName.length > 50) score -= 0.2;
    if (fileName.length > 80) score -= 0.3;
    
    // 特殊字符检查
    const specialCharCount = (fileName.match(/[^a-zA-Z0-9\u4e00-\u9fa5\-_.]/g) || []).length;
    score -= specialCharCount * 0.1;
    
    // 连字符过多检查
    const hyphenCount = (fileName.match(/-/g) || []).length;
    if (hyphenCount > 3) score -= 0.1;
    
    return Math.max(score, 0);
  }
}
```
[Source: architecture.md#components]

### 用户界面集成
```typescript
interface RenameUIState {
  selectedFiles: string[];
  suggestions: Map<string, NamingSuggestion[]>;
  previewMode: boolean;
  batchOperation?: BatchRenameOperation;
  customRules: CustomNamingRule[];
}

class RenameUIController {
  private state: RenameUIState = {
    selectedFiles: [],
    suggestions: new Map(),
    previewMode: false,
    customRules: []
  };
  
  async loadSuggestionsForFiles(fileIds: string[]): Promise<void> {
    this.state.selectedFiles = fileIds;
    
    for (const fileId of fileIds) {
      const analysis = await this.analysisService.getAnalysis(fileId);
      const document = await this.documentService.getDocument(fileId);
      const suggestions = await this.renameEngine.generateSuggestions(
        analysis, 
        document.fileName
      );
      
      this.state.suggestions.set(fileId, suggestions);
    }
    
    this.notifyStateChange();
  }
  
  async previewBatchRename(strategy: NamingStrategy): Promise<BatchRenamePreview> {
    const preview: BatchRenamePreview = {
      files: [],
      conflicts: [],
      summary: {
        totalFiles: this.state.selectedFiles.length,
        successfulRenames: 0,
        conflicts: 0,
        errors: 0
      }
    };
    
    for (const fileId of this.state.selectedFiles) {
      const suggestions = this.state.suggestions.get(fileId) || [];
      const suggestion = suggestions.find(s => s.strategy === strategy) || suggestions[0];
      
      if (suggestion) {
        preview.files.push({
          fileId,
          originalName: await this.getOriginalFileName(fileId),
          suggestedName: suggestion.suggestedName,
          confidence: suggestion.confidence
        });
      }
    }
    
    // 检测冲突
    preview.conflicts = this.detectPreviewConflicts(preview.files);
    preview.summary.conflicts = preview.conflicts.length;
    preview.summary.successfulRenames = preview.files.length - preview.conflicts.length;
    
    return preview;
  }
}
```
[Source: architecture.md#components]

### 性能优化
- **并行处理**: 使用Web Worker并行生成多个文件的命名建议
- **缓存策略**: 缓存文档分析结果和命名建议
- **增量更新**: 只为修改的文件重新生成建议
- **懒加载**: 按需加载自定义规则和模板
[Source: architecture.md#performance-optimization]

### Testing
**测试文件位置**: `tests/renderer/services/SmartRenameEngine.test.ts`
**测试框架**: Jest + React Testing Library
**关键测试场景**:
- 各种文档类型的命名建议准确性
- 中文命名格式正确性测试
- 批量重命名功能完整性
- 自定义规则应用测试
- 文件名冲突处理测试
**测试标准**:
- 命名建议准确率≥80%
- 批量操作成功率≥95%
- 文件名合规性100%
- 冲突检测准确率100%
- 性能响应时间<1秒
[Source: architecture.md#testing-strategy]

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-21 | v1.0 | 初始故事创建 | Bob (SM) |

## Dev Agent Record
*此部分将在开发实施过程中由开发代理填充*

### Agent Model Used
*待填充*

### Debug Log References
*待填充*

### Completion Notes List
*待填充*

### File List
*待填充*

## QA Results
*此部分将在QA代理审查完成后填充*
