# Story 2.3: 文本编辑界面实现

## Status
Completed - 2025-08-22

## Story
**As a** 用户,
**I want** 能够直接在预览界面中编辑文本,
**so that** 我能够快速修改PDF内容而不需要切换到专门的编辑模式

## Acceptance Criteria
1. 点击文本后显示可编辑的文本输入框
2. 保持原有文本的字体、大小、颜色等样式
3. 支持基础文本编辑操作（输入、删除、选择）
4. 实时预览编辑效果
5. 按ESC键或点击其他区域完成编辑
6. 编辑界面与原文本位置精确对齐

## Tasks / Subtasks
- [ ] 创建内联编辑组件 (AC: 1, 6)
  - [ ] 实现可编辑文本输入框组件
  - [ ] 动态定位编辑框到文本位置
  - [ ] 处理编辑框的层级和遮罩
  - [ ] 支持多行文本编辑
- [ ] 样式保持系统 (AC: 2)
  - [ ] 提取原文本的样式信息
  - [ ] 将PDF样式转换为CSS样式
  - [ ] 实现字体、大小、颜色的精确匹配
  - [ ] 处理特殊字体的降级方案
- [ ] 编辑操作支持 (AC: 3)
  - [ ] 实现文本选择功能
  - [ ] 支持复制、粘贴、剪切操作
  - [ ] 添加撤销/重做功能
  - [ ] 处理中文输入法支持
- [ ] 实时预览机制 (AC: 4)
  - [ ] 实现编辑内容的实时渲染
  - [ ] 优化预览性能避免卡顿
  - [ ] 处理文本溢出和自动换行
  - [ ] 同步编辑状态到PDF视图
- [ ] 编辑完成处理 (AC: 5)
  - [ ] 监听ESC键和点击外部事件
  - [ ] 实现编辑确认和取消逻辑
  - [ ] 处理编辑内容的验证
  - [ ] 保存编辑结果到文档状态

## Dev Notes

### 内联编辑组件架构
```typescript
interface InlineTextEditor {
  textBlock: TextBlock;
  isVisible: boolean;
  onSave: (newText: string) => void;
  onCancel: () => void;
}

class InlineTextEditor extends React.Component<InlineTextEditorProps> {
  private inputRef = React.createRef<HTMLTextAreaElement>();
  
  componentDidMount() {
    this.positionEditor();
    this.applyOriginalStyles();
    this.focusAndSelectText();
  }
  
  private positionEditor(): void {
    const { textBlock } = this.props;
    const editorElement = this.inputRef.current;
    
    if (editorElement) {
      const canvasRect = this.getCanvasRect();
      const position = this.coordinateMapper.pdfToCanvas(
        textBlock.x, 
        textBlock.y
      );
      
      editorElement.style.position = 'absolute';
      editorElement.style.left = `${position.x}px`;
      editorElement.style.top = `${position.y}px`;
      editorElement.style.width = `${textBlock.width * this.scale}px`;
      editorElement.style.height = `${textBlock.height * this.scale}px`;
    }
  }
}
```
[Source: architecture.md#components]

### 样式转换系统
```typescript
class StyleConverter {
  convertPDFStyleToCSS(textBlock: TextBlock): CSSStyleDeclaration {
    return {
      fontFamily: this.mapFontFamily(textBlock.fontFamily),
      fontSize: `${textBlock.fontSize * this.scale}px`,
      color: this.convertColor(textBlock.color),
      fontWeight: textBlock.fontWeight || 'normal',
      fontStyle: textBlock.fontStyle || 'normal',
      lineHeight: `${textBlock.lineHeight || 1.2}`,
      textAlign: textBlock.textAlign || 'left',
      letterSpacing: `${textBlock.letterSpacing || 0}px`,
      wordSpacing: `${textBlock.wordSpacing || 0}px`
    };
  }
  
  private mapFontFamily(pdfFont: string): string {
    const fontMap: Record<string, string> = {
      'Times-Roman': 'Times, serif',
      'Helvetica': 'Arial, sans-serif',
      'Courier': 'Courier New, monospace',
      'SimSun': 'SimSun, "宋体", serif',
      'SimHei': 'SimHei, "黑体", sans-serif'
    };
    
    return fontMap[pdfFont] || 'Arial, sans-serif';
  }
}
```
[Source: architecture.md#components]

### 编辑状态管理
```typescript
interface EditingState {
  activeTextBlock: TextBlock | null;
  originalText: string;
  currentText: string;
  isEditing: boolean;
  editHistory: EditOperation[];
}

class EditingStateManager {
  private state: EditingState = {
    activeTextBlock: null,
    originalText: '',
    currentText: '',
    isEditing: false,
    editHistory: []
  };
  
  startEditing(textBlock: TextBlock): void {
    this.state = {
      activeTextBlock: textBlock,
      originalText: textBlock.text,
      currentText: textBlock.text,
      isEditing: true,
      editHistory: []
    };
    
    this.notifyStateChange();
  }
  
  updateText(newText: string): void {
    if (this.state.isEditing) {
      this.addToHistory(this.state.currentText);
      this.state.currentText = newText;
      this.notifyStateChange();
    }
  }
  
  commitEdit(): void {
    if (this.state.activeTextBlock && this.state.isEditing) {
      this.state.activeTextBlock.text = this.state.currentText;
      this.finishEditing();
    }
  }
}
```
[Source: architecture.md#state-management-architecture]

### 实时预览实现
```typescript
class RealTimePreview {
  private previewCanvas: HTMLCanvasElement;
  private renderingContext: CanvasRenderingContext2D;
  
  updatePreview(textBlock: TextBlock, newText: string): void {
    // 清除原文本区域
    this.clearTextArea(textBlock);
    
    // 渲染新文本
    this.renderText(textBlock, newText);
    
    // 更新文本块数据
    textBlock.text = newText;
  }
  
  private renderText(textBlock: TextBlock, text: string): void {
    const ctx = this.renderingContext;
    
    // 设置文本样式
    ctx.font = `${textBlock.fontSize}px ${textBlock.fontFamily}`;
    ctx.fillStyle = textBlock.color;
    ctx.textAlign = textBlock.textAlign as CanvasTextAlign;
    
    // 处理多行文本
    const lines = this.wrapText(text, textBlock.width);
    lines.forEach((line, index) => {
      const y = textBlock.y + (index * textBlock.lineHeight);
      ctx.fillText(line, textBlock.x, y);
    });
  }
  
  private wrapText(text: string, maxWidth: number): string[] {
    const words = text.split(' ');
    const lines: string[] = [];
    let currentLine = '';
    
    for (const word of words) {
      const testLine = currentLine + (currentLine ? ' ' : '') + word;
      const metrics = this.renderingContext.measureText(testLine);
      
      if (metrics.width > maxWidth && currentLine) {
        lines.push(currentLine);
        currentLine = word;
      } else {
        currentLine = testLine;
      }
    }
    
    if (currentLine) {
      lines.push(currentLine);
    }
    
    return lines;
  }
}
```
[Source: architecture.md#core-workflows]

### 键盘事件处理
```typescript
class KeyboardHandler {
  handleKeyDown = (event: KeyboardEvent): void => {
    switch (event.key) {
      case 'Escape':
        this.cancelEditing();
        break;
      case 'Enter':
        if (event.ctrlKey || event.metaKey) {
          this.commitEditing();
        } else {
          this.insertNewLine();
        }
        break;
      case 'Tab':
        event.preventDefault();
        this.insertTab();
        break;
      case 'z':
        if (event.ctrlKey || event.metaKey) {
          event.preventDefault();
          if (event.shiftKey) {
            this.redo();
          } else {
            this.undo();
          }
        }
        break;
    }
  };
  
  private insertNewLine(): void {
    const textarea = this.inputRef.current;
    if (textarea) {
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      const value = textarea.value;
      
      textarea.value = value.substring(0, start) + '\n' + value.substring(end);
      textarea.selectionStart = textarea.selectionEnd = start + 1;
    }
  }
}
```
[Source: architecture.md#components]

### 中文输入法支持
```typescript
class IMEHandler {
  private isComposing = false;
  
  handleCompositionStart = (): void => {
    this.isComposing = true;
  };
  
  handleCompositionEnd = (event: CompositionEvent): void => {
    this.isComposing = false;
    this.handleTextInput(event.data);
  };
  
  handleInput = (event: InputEvent): void => {
    if (!this.isComposing) {
      this.handleTextInput((event.target as HTMLTextAreaElement).value);
    }
  };
  
  private handleTextInput(text: string): void {
    this.editingStateManager.updateText(text);
    this.realTimePreview.updatePreview(this.currentTextBlock, text);
  }
}
```
[Source: architecture.md#components]

### 编辑验证规则
```typescript
class EditValidation {
  validateEdit(originalText: string, newText: string): ValidationResult {
    const errors: string[] = [];
    
    // 长度检查
    if (newText.length > 1000) {
      errors.push('文本长度不能超过1000个字符');
    }
    
    // 特殊字符检查
    if (this.containsInvalidCharacters(newText)) {
      errors.push('包含不支持的特殊字符');
    }
    
    // 格式检查
    if (this.breaksLayout(newText)) {
      errors.push('文本可能会破坏页面布局');
    }
    
    return {
      isValid: errors.length === 0,
      errors,
      warnings: this.generateWarnings(originalText, newText)
    };
  }
}
```
[Source: architecture.md#error-handling-strategy]

### 性能优化
- **虚拟DOM**: 使用React的虚拟DOM优化渲染性能
- **防抖输入**: 输入事件防抖，减少不必要的重渲染
- **Canvas缓存**: 缓存未编辑区域的Canvas内容
- **内存管理**: 及时清理编辑组件的事件监听器
[Source: architecture.md#performance-optimization]

### Testing
**测试文件位置**: `tests/renderer/components/InlineTextEditor.test.tsx`
**测试框架**: Jest + React Testing Library + Canvas Mock
**关键测试场景**:
- 编辑框定位精度测试
- 样式保持准确性测试
- 键盘事件处理测试
- 中文输入法兼容性测试
- 实时预览性能测试
**测试标准**:
- 编辑功能100%覆盖
- 定位精度误差<2px
- 输入响应时间<50ms
- 内存使用稳定
[Source: architecture.md#testing-strategy]

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-21 | v1.0 | 初始故事创建 | Bob (SM) |

## Dev Agent Record
*此部分将在开发实施过程中由开发代理填充*

### Agent Model Used
*待填充*

### Debug Log References
*待填充*

### Completion Notes List
*待填充*

### File List
*待填充*

## QA Results
*此部分将在QA代理审查完成后填充*
